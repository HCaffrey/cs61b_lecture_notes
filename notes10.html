<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>notes10</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="notes10"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-04-11T17:36-0700"/>
<meta name="author" content="michael"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	padding: 5pt;
	font-family: courier, monospace;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">notes10</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Lecture 10</a>
<ul>
<li><a href="#sec-1-1">INHERITANCE</a></li>
<li><a href="#sec-1-2">Inheritance and Constructors</a></li>
<li><a href="#sec-1-3">Invoking Overridden Methods</a></li>
<li><a href="#sec-1-4">The "protected" Keyword</a></li>
<li><a href="#sec-1-5">Class Hierarchies</a></li>
<li><a href="#sec-1-6">Dynamic Method Lookup</a></li>
<li><a href="#sec-1-7">Subtleties of Inheritance</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Lecture 10</h2>
<div class="outline-text-2" id="text-1">

<p>Today's reading:  All of Chapter 7, plus pp. 28-33, 250-257.
</p>
<p>
<a href="original-notes/10">original notes</a>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">INHERITANCE</h3>
<div class="outline-text-3" id="text-1-1">

<p>In Lab 3, you modified several methods in the SList class so that a "tail"
reference could keep track of the end of the list, thereby speeding up the
insertEnd() method.
</p>
<p>
We could have accomplished the same result without modifying SList&ndash;by creating
a new class that inherits all the properties of SList, and then changing only
the methods that need to change.  Let's create a new class called TailList that
inherits the fields and methods of the original SList class.
</p>



<pre class="src src-java"><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">TailList</span> <span style="color: #a020f0;">extends</span> <span style="color: #228b22;">SList</span> {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">The "head" and "size" fields are inherited from SList.</span>
  <span style="color: #a020f0;">private</span> <span style="color: #228b22;">SListNode</span> <span style="color: #a0522d;">tail</span>;
</pre>


<p>
This code declares a TailList class that behaves just like the SList class, but
has an additional field "tail" not present in the SList class.  TailList is
said to be a <span style="text-decoration:underline;">subclass</span> of SList, and SList is the <span style="text-decoration:underline;">superclass</span> of TailList.
A TailList has three fields:  head, size, and tail.
</p>
<p>
A subclass can modify or augment a superclass in at least three ways:
</p><ol>
<li>It can declare new fields.
</li>
<li>It can declare new methods.
</li>
<li>It can override old methods with new implementations.
</li>
</ol>


<p>
We've already seen an example of the first.  Let's try out the third.  The
advantage of TailList is that it can perform the insertEnd() method much more
quickly than a tail-less SList can.  So, let's write a new insertEnd() for
TailList, which will <span style="text-decoration:underline;">override</span> SList's old, slow insertEnd() method.
</p>



<pre class="src src-java"><span style="color: #a020f0;">public</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">insertEnd</span>(<span style="color: #228b22;">Object</span> <span style="color: #a0522d;">obj</span>) {
    <span style="color: #b22222;">// </span><span style="color: #b22222;">Your solution to Lab 3 goes here.</span>
}
</pre>


<p>
The isEmpty(), length(), nth(), and toString() methods of SList do not need any
changes on account of the tail reference.  These methods are inherited from
SList, and there's no need to rewrite them.
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Inheritance and Constructors</h3>
<div class="outline-text-3" id="text-1-2">

<p>What happens when we construct a TailList?  Java executes a TailList
constructor, as you would expect, but <span style="text-decoration:underline;">first</span> it executes the code in the
SList() constructor.  The TailList constructor should initialize fields unique
to TailList.  It can also modify the work done by SList() if appropriate.
</p>



<pre class="src src-java"><span style="color: #a020f0;">public</span> TailList() {
  <span style="color: #b22222;">// </span><span style="color: #b22222;">SList() constructor called automatically; sets size = 0, head = null</span>
  tail = <span style="color: #008b8b;">null</span>;
}
</pre>


<p>
The zero-parameter SList() constructor is always called by default, regardless
of the parameters passed to the TailList constructor.  To change this default
behavior, the TailList constructor can explicitly call any constructor for its
superclass by using the "super" keyword.
</p>



<pre class="src src-java"><span style="color: #a020f0;">public</span> TailList(<span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span>) {
    <span style="color: #a020f0;">super</span>(x);
    tail = <span style="color: #008b8b;">null</span>;
}
</pre>


<p>
The call to "super()" must be the first statement in the constructor.  If a
constructor has no explicit call to "super", and its (nearest) superclass has
no zero-parameter constructor, a compile-time error occurs.  There is no way to
tell Java not to call a superclass constructor.  You have only the power to
choose which of the superclass constructors is called.
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">Invoking Overridden Methods</h3>
<div class="outline-text-3" id="text-1-3">

<p>Sometimes you want to override a method, yet still be able to call the method
implemented in the superclass.  The following example shows how to do this.
Below, we want to reuse the code in SList.insertFront, but we also need to
adjust the tail reference.
</p>



<pre class="src src-java"><span style="color: #a020f0;">public</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">insertFront</span>(<span style="color: #228b22;">Object</span> <span style="color: #a0522d;">obj</span>) {
    <span style="color: #a020f0;">super</span>.insertFront(obj);             <span style="color: #b22222;">// </span><span style="color: #b22222;">Insert at the front of the list.</span>
    <span style="color: #a020f0;">if</span> (size == 1) {                    <span style="color: #b22222;">// </span><span style="color: #b22222;">If necessary,</span>
        tail = head;                    <span style="color: #b22222;">//   </span><span style="color: #b22222;">adjust the tail reference.</span>
    }
}
}
</pre>


<p>
Unlike superclass constructor invocations, ordinary superclass method
invocations need not be the first statement in a method.
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">The "protected" Keyword</h3>
<div class="outline-text-3" id="text-1-4">

<p>I lied when I said that we don't need to modify SList.  One change is
necessary.  The "head" and "size" fields in SList must be declared "protected",
not "private".
</p>



<pre class="src src-java"><span style="color: #a020f0;">public</span> <span style="color: #a020f0;">class</span> <span style="color: #228b22;">SList</span> {
  <span style="color: #a020f0;">protected</span> <span style="color: #228b22;">SListNode</span> <span style="color: #a0522d;">head</span>;
  <span style="color: #a020f0;">protected</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">size</span>;

  [Method definitions.]
}
</pre>


<p>
"protected" is a level of protection somewhere between "public" and "private".
A "protected" field is visible to the declaring class and all its subclasses,
but not to other classes.  "private" fields aren't even visible to the
subclasses.
</p>
<p>
If "head" and "size" are declared private, the method TailList.insertFront
can't access them and won't compile.  If they're declared protected,
insertFront can access them because TailList is a subclass of SList.
</p>
<p>
When you write an ADT, if you think somebody might someday want to write a
subclass of it, declare its vulnerable fields "protected", unless you have a
reason for not wanting subclasses to see them.  Helper methods often should be
declared "protected" as well.
</p>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">Class Hierarchies</h3>
<div class="outline-text-3" id="text-1-5">

<p>Subclasses can have subclasses.  Subclassing is transitive:  if Proletariat is
a subclass of Worker, and Student is a subclass of Proletariat, then Student is
a subclass of Worker.  Furthermore, <span style="text-decoration:underline;">every</span> class is a subclass of the Object
class (including Java's built-in classes like String and BufferedReader.)
Object is at the top of every class hierarchy.
</p>



<pre class="src src-text">      Object
      /    \
  String  Worker
         /      \
Proletariat  Bourgeoisie        Superclasses appear above their subclasses.
   /     \       |
Student  TA   Professor
</pre>


<p>
That's why the "item" field in each listnode is of type Object:  it can
reference any object of any class.  (It can't reference a primitive type,
though.)
</p>
</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6">Dynamic Method Lookup</h3>
<div class="outline-text-3" id="text-1-6">

<p>Here's where inheritance gets interesting.  Any TailList can masquerade as an
SList.  An object of class TailList can be assigned to a variable of type
SList&ndash;but the reverse is not true.  Every TailList is an SList, but not every
SList is a TailList.  It merits repeating:
</p>
<p>
 !!!  <span style="text-decoration:underline;">Every TailList *IS* an SList</span>. !!!   For example:
</p>



<pre class="src src-java"><span style="color: #228b22;">SList</span> <span style="color: #a0522d;">s</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">TailList</span>();         <span style="color: #b22222;">// </span><span style="color: #b22222;">Groovy.</span>
<span style="color: #228b22;">TailList</span> <span style="color: #a0522d;">t</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">SList</span>();         <span style="color: #b22222;">// </span><span style="color: #b22222;">COMPILE-TIME ERROR.</span>
</pre>


<p>
Memorize the following two definitions.
</p><ul>
<li><span style="text-decoration:underline;">Static type</span>:  The type of a variable.
</li>
<li><span style="text-decoration:underline;">Dynamic type</span>:  The class of the object the variable references.
</li>
</ul>


<p>
In the code above, the static type of s is SList, and the dynamic type of s is
TailList.  Henceforth, I will often just say "type" for static type and "class"
for dynamic type.
</p>
<p>
When we invoke an overridden method, Java calls the method for the object's
<span style="text-decoration:underline;">dynamic</span> type, regardless of the variable's static type.
</p>



<pre class="src src-java"><span style="color: #228b22;">SList</span> <span style="color: #a0522d;">s</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">TailList</span>();
s.insertEnd(obj);                 <span style="color: #b22222;">// </span><span style="color: #b22222;">Calls TailList.insertEnd()</span>
s = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">SList</span>();
s.insertEnd(obj);                 <span style="color: #b22222;">// </span><span style="color: #b22222;">Calls SList.insertEnd()</span>
</pre>


<p>
This is called <span style="text-decoration:underline;">dynamic method lookup</span>, because Java automatically looks up the
right method for a given object at run-time.  Why is it interesting?
</p>
<p>
<span style="text-decoration:underline;">WHY DYNAMIC METHOD LOOKUP MATTERS</span>    (Worth reading and rereading)
</p>
<p>                                                                           
Suppose you have a method (in any class) that sorts an SList using only    
SList method calls (but doesn't construct any SLists).  Your method now    
sorts TailLists too, with no changes.                                      
</p>
<p>                                                                           
Suppose you've written a class&ndash;let's call it RunLengthEncoding&ndash;that uses 
SLists extensively.  By changing the constructors so that they create      
TailLists instead of SLists, your class immediately realizes the           
performance improvement that TailLists provide&ndash;without changing anything  
else in the RunLengthEncoding class.                                       
</p>
</div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7">Subtleties of Inheritance</h3>
<div class="outline-text-3" id="text-1-7">

<p>(1)  Suppose we write a new method in the TailList class called eatTail().  We
can't call eatTail on an SList.  We can't even call eatTail on a variable of
type SList that references a TailList.
</p>



<pre class="src src-java"><span style="color: #228b22;">TailList</span> <span style="color: #a0522d;">t</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">TailList</span>();
t.eatTail();                      <span style="color: #b22222;">// </span><span style="color: #b22222;">Groovy.</span>
<span style="color: #228b22;">SList</span> <span style="color: #a0522d;">s</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">TailList</span>();         <span style="color: #b22222;">// </span><span style="color: #b22222;">Groovy--every TailList is an SList.</span>
s.eatTail();                      <span style="color: #b22222;">// </span><span style="color: #b22222;">COMPILE-TIME ERROR.</span>
</pre>


<p>
Why?  Because not every object of class SList has an "eatTail()" method, so
Java can't use dynamic method lookup on the variable s.
</p>
<p>
But if we define eatTail() in SList instead, the statements above compile and
run without errors, even if no eatTail() method is defined in class TailList.
(TailList inherits eatTail() from SList.)
</p>
<p>
(2)  I pointed out earlier that you can't assign an SList object to a TailList
variable.  The rules are more complicated when you assign one variable to
another.
</p>



<pre class="src src-java"><span style="color: #228b22;">SList</span> <span style="color: #a0522d;">s</span>;
<span style="color: #228b22;">TailList</span> <span style="color: #a0522d;">t</span> = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">TailList</span>();
s = t;                            <span style="color: #b22222;">// </span><span style="color: #b22222;">Groovy.</span>
t = s;                            <span style="color: #b22222;">// </span><span style="color: #b22222;">COMPILE-TIME ERROR.</span>
t = (<span style="color: #228b22;">TailList</span>) s;                 <span style="color: #b22222;">// </span><span style="color: #b22222;">Groovy.</span>
s = <span style="color: #a020f0;">new</span> <span style="color: #228b22;">SList</span>();
t = (<span style="color: #228b22;">TailList</span>) s;                 <span style="color: #b22222;">// </span><span style="color: #b22222;">RUN-TIME ERROR:  ClassCastException.</span>
</pre>


<p>
Why does the compiler reject "t = s", but accept "t = (TailList) s"?  It
refuses "t = s" because not every SList is a TailList, and it wants you to
confirm that you're not making a thoughtless mistake.  The cast in the latter
statement is your way of reassuring the compiler that you've designed the
program to make sure that the SList s will always be a TailList.
</p>
<p>
If you're wrong, Java will find out when you run the program, and will crash
with a "ClassCastException" error message.  The error occurs only at run-time
because Java cannot tell in advance what class of object s will reference.
</p>
<p>
Recall that SLists store items of type Object.  When they're recovered, they
usually have to be cast back to a more specific type before they can be used.
Suppose we have a list of Integers.  Recall that nth() returns type Object.
</p>



<pre class="src src-java"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">x</span> = t.nth(1).intValue();                <span style="color: #b22222;">// </span><span style="color: #b22222;">COMPILE-TIME ERROR.</span>
<span style="color: #228b22;">int</span> <span style="color: #a0522d;">y</span> = ( (<span style="color: #228b22;">Integer</span>) t.nth(1) ).intValue();  <span style="color: #b22222;">// </span><span style="color: #b22222;">Groovy.</span>
</pre>


<p>
Some methods are defined on every Object, though.
</p>



<pre class="src src-java"><span style="color: #228b22;">String</span> <span style="color: #a0522d;">z</span> = t.nth(1).toString();             <span style="color: #b22222;">// </span><span style="color: #b22222;">Groovy.</span>
</pre>


<p>
(3)  Java has an "instanceof" operator that tells you whether an object is of
a specific class.  WARNING:  The "o" in "instanceof" is not capitalized.
</p>



<pre class="src src-java"><span style="color: #a020f0;">if</span> (s <span style="color: #a020f0;">instanceof</span> TailList) {
  t = (<span style="color: #228b22;">TailList</span>) s;
}
</pre>


<p>
This instanceof operation will return false if s is null or doesn't reference
a TailList.  It returns true if s references a TailList object&ndash;even if it's
a subclass of TailList.
</p></div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-04-11T17:36-0700</p>
<p class="author">Author: michael</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
