<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>cs61b Lecture Notes</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="cs61b Lecture Notes"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-02-22T14:37-0800"/>
<meta name="author" content="michael"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">cs61b Lecture Notes</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Lecture 2</a>
<ul>
<li><a href="#sec-1-1">1.1 OBJECTS AND CONSTRUCTORS</a></li>
<li><a href="#sec-1-2">1.2 METHODS</a></li>
<li><a href="#sec-1-3">1.3 I/O Classes and Objects in Java</a></li>
<li><a href="#sec-1-4">1.4 Classes for Web Access</a></li>
<li><a href="#sec-1-5">1.5 Postscript:  Object-Oriented Terminology (not examinable)</a></li>
</ul>
</li>
<li><a href="#sec-2">2 Lecture 3</a>
<ul>
<li><a href="#sec-2-1">2.1 DEFINING CLASSES</a></li>
<li><a href="#sec-2-2">2.2 Constructors</a></li>
<li><a href="#sec-2-3">2.3 The "this" Keyword</a></li>
<li><a href="#sec-2-4">2.4 The "static" Keyword</a></li>
<li><a href="#sec-2-5">2.5 Lifetimes of Variables</a></li>
</ul>
</li>
<li><a href="#sec-3">3 Lecture 4</a>
<ul>
<li><a href="#sec-3-1">3.1 PRIMITIVE TYPES</a></li>
<li><a href="#sec-3-2">3.2 Boolean Values</a></li>
<li><a href="#sec-3-3">3.3 CONDITIONALS</a></li>
<li><a href="#sec-3-4">3.4 THE "return" KEYWORD</a></li>
</ul>
</li>
<li><a href="#sec-4">4 Lecture 5</a>
<ul>
<li><a href="#sec-4-1">4.1 LOOPS</a>
<ul>
<li><a href="#sec-4-1-1">4.1.1 "while" Loops</a></li>
<li><a href="#sec-4-1-2">4.1.2 "for" Loops</a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2 ARRAYS</a></li>
<li><a href="#sec-4-3">4.3 Primes Revisited</a></li>
<li><a href="#sec-4-4">4.4 Multi-Dimensional Arrays</a></li>
</ul>
</li>
<li><a href="#sec-5">5 Lecture 6</a>
<ul>
<li><a href="#sec-5-1">5.1 MORE ARRAYS</a></li>
<li><a href="#sec-5-2">5.2 Automatic Array Construction</a></li>
<li><a href="#sec-5-3">5.3 MORE LOOPS</a>
<ul>
<li><a href="#sec-5-3-1">5.3.1 "do" Loops</a></li>
<li><a href="#sec-5-3-2">5.3.2 The "break" and "continue" Statements</a></li>
</ul>
</li>
<li><a href="#sec-5-4">5.4 CONSTANTS</a></li>
<li><a href="#sec-5-5">5.5 SCOPE</a></li>
</ul>
</li>
<li><a href="#sec-6">6 Lecture 7</a>
<ul>
<li><a href="#sec-6-1">6.1 LISTS</a></li>
<li><a href="#sec-6-2">6.2 LINKED LISTS (a recursive data type)</a></li>
<li><a href="#sec-6-3">6.3 Linked lists vs. array lists</a></li>
<li><a href="#sec-6-4">6.4 Lists of Objects</a></li>
<li><a href="#sec-6-5">6.5 A List Class</a></li>
</ul>
</li>
<li><a href="#sec-7">7 Lecture 8</a>
<ul>
<li><a href="#sec-7-1">7.1 THE "public" AND "private" KEYWORDS</a></li>
<li><a href="#sec-7-2">7.2 The SList ADT</a></li>
<li><a href="#sec-7-3">7.3 DOUBLY-LINKED LISTS</a></li>
</ul>
</li>
<li><a href="#sec-8">8 Lecture 9</a>
<ul>
<li><a href="#sec-8-1">8.1 THE STACK AND THE HEAP</a></li>
<li><a href="#sec-8-2">8.2 Parameter Passing</a></li>
<li><a href="#sec-8-3">8.3 Binary search</a></li>
<li><a href="#sec-8-4">8.4 Scope and Recursion</a></li>
</ul>
</li>
<li><a href="#sec-9">9 Lecture 10</a>
<ul>
<li><a href="#sec-9-1">9.1 INHERITANCE</a></li>
<li><a href="#sec-9-2">9.2 Inheritance and Constructors</a></li>
<li><a href="#sec-9-3">9.3 Invoking Overridden Methods</a></li>
<li><a href="#sec-9-4">9.4 The "protected" Keyword</a></li>
<li><a href="#sec-9-5">9.5 Class Hierarchies</a></li>
<li><a href="#sec-9-6">9.6 Dynamic Method Lookup</a></li>
<li><a href="#sec-9-7">9.7 Subtleties of Inheritance</a></li>
</ul>
</li>
<li><a href="#sec-10">10 Lecture 11</a>
<ul>
<li><a href="#sec-10-1">10.1 equals()</a></li>
<li><a href="#sec-10-2">10.2 "for each" LOOPS</a></li>
<li><a href="#sec-10-3">10.3 TESTING</a>
<ul>
<li><a href="#sec-10-3-1">10.3.1 Modular Testing</a></li>
<li><a href="#sec-10-3-2">10.3.2 Integration Testing</a></li>
<li><a href="#sec-10-3-3">10.3.3 Result Verification</a></li>
<li><a href="#sec-10-3-4">10.3.4 Regression Testing</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-11">11 Lecture 12</a>
<ul>
<li><a href="#sec-11-1">11.1 ABSTRACT CLASSES</a></li>
<li><a href="#sec-11-2">11.2 JAVA INTERFACES</a></li>
</ul>
</li>
<li><a href="#sec-12">12 Lecture 13</a>
<ul>
<li><a href="#sec-12-1">12.1 JAVA PACKAGES</a>
<ul>
<li><a href="#sec-12-1-1">12.1.1 Using Packages</a></li>
<li><a href="#sec-12-1-2">12.1.2 Building Packages</a></li>
</ul>
</li>
<li><a href="#sec-12-2">12.2 ITERATORS</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Lecture 2</h2>
<div class="outline-text-2" id="text-1">

<p>Today's reading:  Sierra &amp; Bates, Chapter 2; pp. 54-58, 154-160, 661, 669.
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> OBJECTS AND CONSTRUCTORS</h3>
<div class="outline-text-3" id="text-1-1">





<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">s</span>;           <span style="color: #99968b;">// </span><span style="color: #99968b;">Step 1:      declare a String variable.</span>
s = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">String</span>();   <span style="color: #99968b;">// </span><span style="color: #99968b;">Steps 2, 3:  construct new empty String; assign it to s.</span>
</pre>


<p>
At this point, s is a variable that 
references an "empty" String, i.e.  
a String containing zero characters. 
</p>
<p>
<img src="ditaa-images/img10_bb39b419e4e832fac0134d053d5b2dd655a0add9.png"  alt="ditaa-images/img10_bb39b419e4e832fac0134d053d5b2dd655a0add9.png" />
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">s</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">String</span>();  <span style="color: #99968b;">// </span><span style="color: #99968b;">Steps 1, 2, 3 combined.</span>
s = <span style="color: #95e454;">"Yow!"</span>;               <span style="color: #99968b;">// </span><span style="color: #99968b;">Construct a new String; make s a reference to it.</span>
</pre>



<p>
<img src="ditaa-images/img3_ef6ead9258097e8b7b5ea46500bfe235f0f9febe.png"  alt="ditaa-images/img3_ef6ead9258097e8b7b5ea46500bfe235f0f9febe.png" />
</p>




<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">s2</span> = s;            <span style="color: #99968b;">// </span><span style="color: #99968b;">Copy the reference stored in s into s2.</span>
</pre>



<p>
<img src="ditaa-images/img4_d4659e74db1a984d47f8a308d8d5de7abc4dd129.png"  alt="ditaa-images/img4_d4659e74db1a984d47f8a308d8d5de7abc4dd129.png" />
</p>

<p>
Now s and s2 reference the same object.
</p>



<pre class="src src-java">s2 = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">String</span>(s);       <span style="color: #99968b;">// </span><span style="color: #99968b;">Construct a copy of object; store reference in s2.</span>
</pre>



<p>
<img src="ditaa-images/img5_d22e4d66d1296af933b900d0ede3f222a2c87b6f.png"  alt="ditaa-images/img5_d22e4d66d1296af933b900d0ede3f222a2c87b6f.png" />
</p>

<p>
Now they refer to two different, but identical, objects.
</p>
<p>
Think about that.  When Java executes that line, it does the following things,
in the following order.
</p><ul>
<li>Java looks inside the variables to see where it's pointing.
</li>
<li>Java follows the pointer to the String object.
</li>
<li>Java reads the characters stored in that String object.
</li>
<li>Java creates a new String object that stores a copy of those characters.
</li>
<li>Java stores a reference to the new String object in s2.
</li>
</ul>


<p>
We've seen three String constructors:
</p><ol>
<li>new String() constructs an <span style="text-decoration:underline;">empty string</span>&ndash;it's a string, but it
       contains zero characters.
</li>
<li>"Yow!" constructs a string containing the characters Yow!.
</li>
<li>new String(s) takes a <span style="text-decoration:underline;">parameter</span> s.  Then it makes a copy of the object
       that s references.
</li>
</ol>


<p>
Constructors <span style="text-decoration:underline;">always</span> have the same name as their class, except the special
constructor "stuffinquotes".  That's the only exception.
</p>
<p>
Observe that "new String()" can take no parameters, or one parameter.  These
are two different constructors&ndash;one that is called by "new String()", and one
that is called by "new String(s)".  (Actually, there are many more than
two&ndash;check out the online Java API to see all the possibilities.)
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> METHODS</h3>
<div class="outline-text-3" id="text-1-2">

<p>Let's look at some methods that aren't constructors.
</p>



<pre class="src src-java">s2 = s.toUppercase();       <span style="color: #99968b;">// </span><span style="color: #99968b;">Create a string like s, but in all upper case.</span>
</pre>



<p>
<img src="ditaa-images/img6_663c7234bd18e2eb059e19f965c46b52a754a4ad.png"  alt="ditaa-images/img6_663c7234bd18e2eb059e19f965c46b52a754a4ad.png" />
</p>




<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">s3</span> = s2.concat(<span style="color: #95e454;">"!!"</span>);             <span style="color: #99968b;">// </span><span style="color: #99968b;">Also written:  s3 = s2 + "!!";</span>
</pre>



<p>
<img src="ditaa-images/img7_4923512868bfa9d7f3863f1388e52de55418c3d5.png"  alt="ditaa-images/img7_4923512868bfa9d7f3863f1388e52de55418c3d5.png" />
</p>




<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">s4</span> = <span style="color: #95e454;">"*"</span>.concat(s2).concat(<span style="color: #95e454;">"*"</span>);  <span style="color: #99968b;">// </span><span style="color: #99968b;">Also written:  s4 = "*" + s + "*";</span>
</pre>



<p>
<img src="ditaa-images/img8_099c9bb6c3af0de1ca50ecce4bbe3e9a22ff4d57.png"  alt="ditaa-images/img8_099c9bb6c3af0de1ca50ecce4bbe3e9a22ff4d57.png" />
</p>

<p>
Now, here's an important fact:  when Java executed the line
</p>



<pre class="src src-java">s2 = s.toUppercase();
</pre>


<p>
the String object "Yow!" did <span style="text-decoration:underline;">not</span> change.  Instead, s2 itself changed to
reference a new object.  Java wrote a new "pointer" into the variable s2, so
now s2 points to a different object than it did before.
</p>
<p>
Unlike in C, in Java Strings are <span style="text-decoration:underline;">immutable</span>&ndash;once they've been constructed,
their contents never change.  If you want to change a String object, you've got
to create a brand new String object that reflects the changes you want.  This
is not true of all objects; most Java objects let you change their contents.
</p>
<p>
You might find it confusing that methods like "toUppercase" and "concat" return
newly created String objects, though they are not constructors.  The trick is
that those methods calls constructors internally, and return the newly
constructed Strings.
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> I/O Classes and Objects in Java</h3>
<div class="outline-text-3" id="text-1-3">


<p>
Here are some objects in the System class for interacting with a user:
</p>
<p>
  System.out is a PrintStream object that outputs to the screen.
  System.in is an InputStream object that reads from the keyboard.
    [Reminder:  this is shorthand for "System.in is a variable that references
                an InputStream object."]
</p>
<p>
But System.in doesn't have methods to read a line directly.  There is a method
called readLine that does, but it is defined on BufferedReader objects.
</p>
<ul>
<li>How do we construct a BufferedReader?  One way is with an InputStreamReader.
</li>
<li>How do we construct an InputStreamReader?  We need an InputStream.
</li>
<li>How do we construct an InputStream?  System.in is one.
</li>
</ul>

<p>(You can figure all of this out by looking at the constructors in the online
Java libraries API&ndash;specifically, in the java.io library.)
</p>
<p>
Why all this fuss?
</p>
<p>
InputStream objects (like System.in) read raw data from some source (like the
keyboard), but don't format the data.
</p>
<p>
InputStreamReader objects compose the raw data into characters (which are
typically two bytes long in Java).
</p>
<p>
BufferedReader objects compose the characters into entire lines of text.
</p>
<p>
Why are these tasks divided among three different classes?  So that any one
task can be reimplemented (say, for improved speed) without changing the other
two.
</p>
<p>
Here's a complete Java program that reads a line from the keyboard and prints
it on the screen.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #63b8ff;">java.io.*</span>;

<span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">SimpleIO</span> {
    <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">main</span>(<span style="color: #92a65e; font-weight: bold;">String</span>[] <span style="color: #cae682;">arg</span>) <span style="color: #8ac6f2; font-weight: bold;">throws</span> <span style="color: #92a65e; font-weight: bold;">Exception</span> {
        <span style="color: #92a65e; font-weight: bold;">BufferedReader</span> <span style="color: #cae682;">keybd</span> =
            <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">BufferedReader</span>(<span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">InputStreamReader</span>(System.in));
        System.out.println(keybd.<span style="color: #92a65e; font-weight: bold;">readLine</span>());
    }
}
</pre>


<p>
Don't worry if you don't understand the first three lines; we'll learn the
underlying ideas eventually.  The first line is present because to use the Java
libraries, other than java.lang, you need to "import" them.  java.io includes
the InputStreamReader and BufferedReader classes.
</p>
<p>
The second line just gives the program a name, "SimpleIO".
</p>
<p>
The third line is present because any Java program always begins execution at a
method named "main", which is usually defined more or less as above.  When you
write a Java program, just copy the line of code, and plan to understand it a
few weeks from now.
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Classes for Web Access</h3>
<div class="outline-text-3" id="text-1-4">


<p>
Let's say we want to read a line of text from the White House Web page.  (The
line will be HTML, which looks ugly.  You don't need to understand HTML.)
</p>
<p>
How to read a line of text?  With readLine on BufferedReader.
How to create a BufferedReader?  With an InputStreamReader.
How to create a InputStreamReader?  With an InputStream.
How to create an InputStream?  With a URL.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #63b8ff;">java.net.*</span>;
<span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #63b8ff;">java.io.*</span>;

<span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">WHWWW</span> {
    <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">main</span>(<span style="color: #92a65e; font-weight: bold;">String</span>[] <span style="color: #cae682;">arg</span>) <span style="color: #8ac6f2; font-weight: bold;">throws</span> <span style="color: #92a65e; font-weight: bold;">Exception</span> {
        <span style="color: #92a65e; font-weight: bold;">URL</span> <span style="color: #cae682;">u</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">URL</span>(<span style="color: #95e454;">"<a href="http://www.whitehouse.gov/">http://www.whitehouse.gov</a></span><span style="color: #92a65e; font-weight: bold;"><a href="http://www.whitehouse.gov/">/</a>");</span>
<span style="color: #92a65e; font-weight: bold;">        InputStream</span> <span style="color: #cae682;">ins</span> = u.openStream();
        <span style="color: #92a65e; font-weight: bold;">InputStreamReader</span> <span style="color: #cae682;">isr</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">InputStreamReader</span>(ins);
        <span style="color: #92a65e; font-weight: bold;">BufferedReader</span> <span style="color: #cae682;">whiteHouse</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">BufferedReader</span>(isr);
        System.out.println(whiteHouse.<span style="color: #92a65e; font-weight: bold;">readLine</span>());
    }
}
</pre>


</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Postscript:  Object-Oriented Terminology (not examinable)</h3>
<div class="outline-text-3" id="text-1-5">


<p>
In the words of Turing Award winner Nicklaus Wirth, "Object-oriented
programming (OOP) solidly rests on the principles and concepts of traditional
procedural programming.  OOP has not added a single novel concept &hellip; along
with the OOP paradigm came an entirely new terminology with the purpose of
mystifying the roots of OOP."  Here's a translation guide.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Procedural Programming</th><th scope="col" class="left">Object-Oriented Programming</th></tr>
</thead>
<tbody>
<tr><td class="left">record / structure</td><td class="left">object</td></tr>
<tr><td class="left">record type</td><td class="left">class</td></tr>
<tr><td class="left">extending a type</td><td class="left">declaring a subclass</td></tr>
<tr><td class="left">procedure</td><td class="left">method</td></tr>
<tr><td class="left">procedure call</td><td class="left">sending a message to the method [ack!  phthhht!]</td></tr>
</tbody>
</table>


<p>
I won't ever talk about "sending a message" in this class.  I think it's a
completely misleading metaphor.  In computer science, message-passing normally
implies asynchrony: that is, the process that sends a message can continue
executing while the receiving process receives the message and acts on it.
But that's NOT what it means in object-oriented programming:  when a Java
method "sends a message" to another method, the former method is frozen until
the latter methods completes execution, just like with procedure calls in most
languages.  But you should probably know that this termology exists, much as it
sucks, because you'll probably run into it sooner or later.
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Lecture 3</h2>
<div class="outline-text-2" id="text-2">

<p>Today's reading:  Sierra &amp; Bates, pp. 71-74, 76, 85, 240-249, 273-281, 308-309.
</p>
</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> DEFINING CLASSES</h3>
<div class="outline-text-3" id="text-2-1">

<p>An object is a repository of data.  <span style="text-decoration:underline;">Fields</span> are variables that hold the data
stored in objects.  Fields in objects are also known as <span style="text-decoration:underline;">instance variables</span>.
In Java, fields are addressed much like methods are, but fields never have
parameters, and no parentheses appear after them.  For example, suppose that
amanda is a Human object.  Then amanda.introduce() is a method call, and
amanda.age is a field.  Let's write a <span style="text-decoration:underline;">class definition</span> for the Human class.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">Human</span> {
    <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">age</span>;                <span style="color: #99968b;">// </span><span style="color: #99968b;">The Human's age (an integer).</span>
    <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">name</span>;            <span style="color: #99968b;">// </span><span style="color: #99968b;">The Human's name.</span>

    <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">introduce</span>() {      <span style="color: #99968b;">// </span><span style="color: #99968b;">This is a _method definition_.</span>
        System.out.println(<span style="color: #95e454;">"I'm "</span> + name + <span style="color: #95e454;">" and I'm "</span> + age + <span style="color: #95e454;">" years old."</span>);
    }
}
</pre>


<p>
"age" and "name" are both fields of a Human object.  Now that we've defined the
Human class, we can construct as many Human objects as we want.  Each Human
object we create can have different values of age and name.  We might create
amanda by executing the following code.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">Human</span> <span style="color: #cae682;">amanda</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">Human</span>();    <span style="color: #99968b;">// </span><span style="color: #99968b;">Create amanda.</span>
amanda.age = <span style="color: #ffa07a;">6</span>;                <span style="color: #99968b;">// </span><span style="color: #99968b;">Set amanda's fields.</span>
amanda.name = <span style="color: #95e454;">"Amanda"</span>;
amanda.introduce();            <span style="color: #99968b;">// </span><span style="color: #99968b;">_Method call_ has amanda introduce herself.</span>
</pre>



<p>
<img src="ditaa-images/img13_27421ef0c82df17e5737f8428ec6e33f883f3823.png"  alt="ditaa-images/img13_27421ef0c82df17e5737f8428ec6e33f883f3823.png" />
</p>

<p>
The output is:    I'm Amanda and I'm 6 years old.
</p>
<p>
Why is it that, inside the definition of introduce(), we don't have to write
"amanda.name" and "amanda.age"?  When we invoke "amanda.introduce()", Java
remembers that we are calling introduce() <span style="text-decoration:underline;">on</span> the object that "amanda"
references.  The methods defined inside the Human class remember that we're
referring to amanda's name and age.  If we had written "rishi.introduce()", the
introduce method would print rishi's name and age instead.  If we want to mix
two or more objects, we can.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">Human</span> {
    <span style="color: #99968b;">// </span><span style="color: #99968b;">Include all the stuff from the previous definition of Human here.</span>

    <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">copy</span>(<span style="color: #92a65e; font-weight: bold;">Human</span> <span style="color: #cae682;">original</span>) {
        age = original.age;
        name = original.name;
    }
}
</pre>


<p>
Now, "amanda.copy(rishi)" copies rishi's fields to amanda.
</p>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Constructors</h3>
<div class="outline-text-3" id="text-2-2">

<p>Let's write a constructor, a method that constructs a Human.  The constructor
won't actually contain code that does the creating; rather, Java provides a
brand new object for us right at the beginning of the constructor, and all you
have to write (if you want) in the constructor is code to initialize the new
object.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">Human</span> {
    <span style="color: #99968b;">// </span><span style="color: #99968b;">Include all the stuff from the previous definitions here.</span>

    <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">Human</span>(<span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">givenName</span>) {
        age = <span style="color: #ffa07a;">6</span>;
        name = givenName;
    }
}
</pre>


<p>
Notice that the constructor is named "Human", and it returns an object of type
"Human".  This constructor is called whenever we write "new Human(s)", where s
is a String reference.  Now, we can shorten amanda's coming-out party to
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">Human</span> <span style="color: #cae682;">amanda</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">Human</span>(<span style="color: #95e454;">"Amanda"</span>);
amanda.introduce();
</pre>


<p>
These lines accomplish precisely the same result as amanda's previous four
lines.
</p>
<p>
You might ask&hellip;why were we able to create a Human object before we wrote a
constructor?  Java provides every class with a default constructor, which takes
no parameters and does no initializing.  Hence, when we wrote
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">Human</span> <span style="color: #cae682;">amanda</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">Human</span>();
</pre>


<p>
we created a new, blank Human.  If the default constructor were explicitly
written, it would look like this:
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">Human</span>() {
}
</pre>


<p>
Warning:  if you write your own Human constructor, even if it takes parameters,
the default constructor goes away.  If you want to have the default constructor
<span style="text-decoration:underline;">and</span> another constructor, you must define both explicitly.
</p>
<p>
You can override the default constructor by explicitly writing your own
constructor with no parameters.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">Human</span> {
    <span style="color: #99968b;">// </span><span style="color: #99968b;">Include all the stuff from the previous definitions here.</span>

    <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">Human</span>() {
        age = <span style="color: #ffa07a;">0</span>;
        name = <span style="color: #95e454;">"Untitled"</span>;
    }
}
</pre>


</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> The "this" Keyword</h3>
<div class="outline-text-3" id="text-2-3">

<p>A method invocation, like "amanda.introduce()", implicitly passes an object
(in this example, amanda) as a parameter called "this".  So we can rewrite our
last constructor as follows without changing its meaning.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">Human</span>() {
    <span style="color: #8ac6f2; font-weight: bold;">this</span>.age = <span style="color: #ffa07a;">0</span>;
    <span style="color: #8ac6f2; font-weight: bold;">this</span>.name = <span style="color: #95e454;">"Untitled"</span>;
}
</pre>


<p>
In this case, "this" is optional.  However, if the parameters or local
variables of a method have the same name as the fields of an object, then the
former have priority, and the "this" keyword is needed to refer to the object's
fields.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">change</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">age</span>) {
    <span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">name</span> = <span style="color: #95e454;">"Tom"</span>;

    <span style="color: #8ac6f2; font-weight: bold;">this</span>.age = age;
    <span style="color: #8ac6f2; font-weight: bold;">this</span>.name = name;
}
</pre>


<p>
When we call "amanda.change(11)", "this" is assigned the same value as "amanda"
before the change() method begins execution.
</p>

<p>
<img src="ditaa-images/img14_31fc2b446c21c2e3ba633608733be89a99e5fa88.png"  alt="ditaa-images/img14_31fc2b446c21c2e3ba633608733be89a99e5fa88.png" />
</p>

<p>
Now, when Java executes "this.age = age", it overwrites the 6 with an 11.
When Java executes "this.name = name", it overwrites amanda's name as below.
</p>

<p>
<img src="ditaa-images/img15_2559c49357dcdd9627276b7d92640d5d5913322f.png"  alt="ditaa-images/img15_2559c49357dcdd9627276b7d92640d5d5913322f.png" />
</p>

<p>
A statement like "this = amanda;" will trigger a compile-time error.
</p>
</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> The "static" Keyword</h3>
<div class="outline-text-3" id="text-2-4">

<p>A <span style="text-decoration:underline;">static field</span> is a single variable shared by a whole class of objects; its
value does not vary from object to object.  For example, if "numberOfHumans" is
the number of Human objects that have been constructed, it is not appropriate
for each object to have its own copy of this number; every time a new Human is
created, we would have to update every Human.
</p>
<p>
If we declare a field "static", there is just one field for the whole class.
Static fields are also called <span style="text-decoration:underline;">class variables</span>.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">Human</span> {
    <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">numberOfHumans</span>;

    <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">age</span>;
    <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">name</span>;

    <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">Human</span>() {
        numberOfHumans++;    <span style="color: #99968b;">// </span><span style="color: #99968b;">The constructor increments the number by one.</span>
    }
}
</pre>


<p>
If we want to look at the variable numberOfHumans from another class, we write
it in the usual notation, but we prefix it with the class name rather than the
name of a specific object.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">kids</span> = Human.numberOfHumans / <span style="color: #ffa07a;">4</span>;  <span style="color: #99968b;">// </span><span style="color: #99968b;">Good.</span>
<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">kids</span> = amanda.numberOfHumans / <span style="color: #ffa07a;">4</span>; <span style="color: #99968b;">// </span><span style="color: #99968b;">This works too, but has nothing to</span>
                                      <span style="color: #99968b;">// </span><span style="color: #99968b;">do with amanda specifically.  Don't</span>
                                      <span style="color: #99968b;">// </span><span style="color: #99968b;">do this; it's bad (confusing) style.</span>
</pre>


<p>
System.in and System.out are other examples of static fields.
</p>
<p>
Methods can be static too.  A <span style="text-decoration:underline;">static method</span> doesn't implicitly pass an object
as a parameter.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">Human</span> {
    ...
    <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">void</span> printHumans() {
        System.out.println(numberOfHumans);
    }
}
</pre>


<p>
Now, we can call "Human.printHumans()" from another class.  We can also call
"amanda.printHumans()", and it works, but it's bad style, and amanda will NOT
be passed along as "this".
</p>
<p>
The main() method is always static, because when we run a program, we are not
passing an object in.
</p>

<p>
<img src="ditaa-images/img16_d1097fba485b6f100c1e892f4d01eb6069838a6b.png"  alt="ditaa-images/img16_d1097fba485b6f100c1e892f4d01eb6069838a6b.png" />
</p>

<p>
Any attempt to reference "this" will cause a compile-time error.
</p>
</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Lifetimes of Variables</h3>
<div class="outline-text-3" id="text-2-5">


<ul>
<li>A local variable (declared in a method) is gone forever as soon as the method
  in which it's declared finishes executing.  (If it references an object, the
  object might continue to exist, though.)
</li>
<li>An instance variable (non-static field) lasts as long as the object exists.
  An object lasts as long as there's a reference to it.
</li>
<li>A class variable (static field) lasts as long as the program runs.
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Lecture 4</h2>
<div class="outline-text-2" id="text-3">

<p>Today's reading:  S&amp;B pp. 10-14, 49-53, 75, 78-79, 86, 117, 286-287, 292, 660.
</p>
</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> PRIMITIVE TYPES</h3>
<div class="outline-text-3" id="text-3-1">

<p>Not all variables are references to objects.  Some variables are primitive
types, which store values like "3", "7.2", "h", and "false".  They are:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">byte:</td><td class="left">A 8-bit integer in the range -128&hellip;127.  (One bit is the sign.)</td></tr>
<tr><td class="left">short:</td><td class="left">A 16-bit integer in the range -32768&hellip;32767.</td></tr>
<tr><td class="left">int:</td><td class="left">A 32-bit integer in the range -2147483648&hellip;2147483647.</td></tr>
<tr><td class="left">long:</td><td class="left">A 64-bit integer, range -9223372036854775808&hellip;9223372036854775807.</td></tr>
<tr><td class="left">double:</td><td class="left">A 64-bit floating-point number like 18.355625430920409.</td></tr>
<tr><td class="left">float:</td><td class="left">A 32-bit floating-point number; has fewer digits of precision.</td></tr>
<tr><td class="left">boolean:</td><td class="left">"true" or "false".</td></tr>
<tr><td class="left">char:</td><td class="left">A single character.</td></tr>
</tbody>
</table>


<p>
long values are written with an L on the end:  long x = 43L;
This tells the compiler to internally write out "43" in a 64-bit format.
double and float values must have a decimal point:  double y = 18.0;
float values are written with an f at the end:  float f = 43.9f;
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left"></th><th scope="col" class="left">Object types</th><th scope="col" class="left">Primitive types</th></tr>
</thead>
<tbody>
<tr><td class="left">Variable contains a</td><td class="left">reference</td><td class="left">value</td></tr>
<tr><td class="left">How defined?</td><td class="left">class definition</td><td class="left">built into Java</td></tr>
<tr><td class="left">How created?</td><td class="left">"new"</td><td class="left">"6", "3.4", "true"</td></tr>
<tr><td class="left">How initialized?</td><td class="left">constructor</td><td class="left">default (usually zero)</td></tr>
<tr><td class="left">How used?</td><td class="left">methods</td><td class="left">operators ("+", "*", etc.)</td></tr>
</tbody>
</table>


<p>
Operations on int, long, short, and byte types.
</p>


<pre class="src src-text">-x               x * y 
x + y            x / y    &lt;-- rounds toward zero (drops the remainder).
x - y            x % y    &lt;-- calculates the remainder of x / y.
</pre>

<p>
Except for "%", these operations are also available for doubles and floats.
Floating-point division ("/") doesn't round to an integer, but it does
round off after a certain number of bits determined by the storage space.
</p>
<p>
The java.lang library has more operations in&hellip;
</p><ul>
<li>the Math class.
</li>
</ul>




<pre class="src src-java">x = Math.abs(y);  <span style="color: #99968b;">// </span><span style="color: #99968b;">Absolute value.  Also see Math.sqrt, Math.sin, etc.</span>
</pre>

<ul>
<li>the Integer class.
</li>
</ul>




<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">x</span> = Integer.parseInt(<span style="color: #95e454;">"1984"</span>);  <span style="color: #99968b;">// </span><span style="color: #99968b;">Convert a string to a number.</span>
</pre>

<ul>
<li>the Double class.
</li>
</ul>




<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">double</span> <span style="color: #cae682;">d</span> = Double.parseDouble(<span style="color: #95e454;">"3.14"</span>);
</pre>


<p>
Converting types:  integers can be assigned to variables of longer types.
</p>


<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span> = <span style="color: #ffa07a;">43</span>; 
<span style="color: #92a65e; font-weight: bold;">long</span> <span style="color: #cae682;">l</span> = <span style="color: #ffa07a;">43</span>;    <span style="color: #99968b;">// </span><span style="color: #99968b;">Okay, because longs are a superset of ints.</span>
l = i;          <span style="color: #99968b;">// </span><span style="color: #99968b;">Okay, because longs are a superset of ints.</span>
i = l;          <span style="color: #99968b;">// </span><span style="color: #99968b;">Compiler ERROR.</span>
i = (<span style="color: #92a65e; font-weight: bold;">int</span>) l;    <span style="color: #99968b;">// </span><span style="color: #99968b;">Okay.</span>
</pre>

<p>
The string "(int)" is called a cast, and it casts the long into an int.  In the
process, high bits will be lost if l does not fit in the range -2147483648&hellip;
2147483647 Java won't let you compile "i = l" because it's trying to protect you 
from accidentally creating a nonsense value and a hard-to-find bug. Java
requires you to explicitly cast longs to ints to show your acknowledgment that
you may be destroying information.
</p>
<p>
Similarly, "float f = 5.5f; double d = f;" is fine, but you need an explicit
cast for "double d = 5.5; float f = (float) d;".  Integers (even longs) can be
directly assigned to floating-point variables (even floats) without a cast, but
the reverse requires a cast because the number is truncated to an integer.
</p>
</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Boolean Values</h3>
<div class="outline-text-3" id="text-3-2">


<p>
A boolean value is either "true" or "false".  Booleans have operations of their
own, signified "&amp;&amp;" (and), "||" (or), and "!" (not).
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">a</th><th scope="col" class="left">b</th><th scope="col" class="left">a &amp;&amp; b</th><th scope="col" class="left">a &#124; &#124; b</th><th scope="col" class="left">!a</th></tr>
</thead>
<tbody>
<tr><td class="left">false</td><td class="left">false</td><td class="left">false</td><td class="left">false</td><td class="left">true</td></tr>
<tr><td class="left">false</td><td class="left">true</td><td class="left">false</td><td class="left">true</td><td class="left"></td></tr>
<tr><td class="left">true</td><td class="left">false</td><td class="left">false</td><td class="left">true</td><td class="left">false</td></tr>
<tr><td class="left">true</td><td class="left">true</td><td class="left">true</td><td class="left">true</td><td class="left"></td></tr>
</tbody>
</table>


<p>
Boolean values can be specified directly ("true", "false") or be created by
the comparison operators "==", "&lt;", "&gt;", "&lt;=", "&gt;=", "!=" (not equal to).
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">boolean</span> <span style="color: #cae682;">x</span> = <span style="color: #ffa07a;">3</span> == <span style="color: #ffa07a;">5</span>;       <span style="color: #99968b;">// </span><span style="color: #99968b;">x is now false.</span>
x = <span style="color: #ffa07a;">4.5</span> &gt;= <span style="color: #ffa07a;">4.5</span>;           <span style="color: #99968b;">// </span><span style="color: #99968b;">x is now true.</span>
x = <span style="color: #ffa07a;">4</span> != <span style="color: #ffa07a;">5</span> - <span style="color: #ffa07a;">1</span>;           <span style="color: #99968b;">// </span><span style="color: #99968b;">x is now false.</span>
x = <span style="color: #7fffd4;">false</span> == (<span style="color: #ffa07a;">3</span> == <span style="color: #ffa07a;">0</span>);    <span style="color: #99968b;">// </span><span style="color: #99968b;">x is now true.</span>
</pre>


</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> CONDITIONALS</h3>
<div class="outline-text-3" id="text-3-3">

<p>An "if" statement uses a boolean expression to decide whether to execute a set
of statements.  The form is
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">if</span> (boolValue) {
    statements;
}
</pre>


<p>
The statements are executed if and only if "boolValue" is "true".  The
parentheses around the boolean expression are required (for no good reason).
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">boolean</span> <span style="color: #cae682;">pass</span> = score &gt;= <span style="color: #ffa07a;">75</span>;
<span style="color: #8ac6f2; font-weight: bold;">if</span> (pass) {
    output(<span style="color: #95e454;">"You pass CS 61B"</span>);
} <span style="color: #8ac6f2; font-weight: bold;">else</span> {
    <span style="color: #99968b;">// </span><span style="color: #99968b;">The following line executes if and only if score &lt; 75.</span>
    output(<span style="color: #95e454;">"You are such an unbelievable loser"</span>);
}
</pre>


<p>
if-then-else clauses can be (1) nested and (2) daisy-chained.  Nesting allows
you to build decision trees.  Daisy-chaining allows you to present more than
two alternatives.  For instance, suppose you want to find the maximum of three
numbers.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">if</span> (x &gt; y) {
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (x &gt; z) {
        maximum = x;
    } <span style="color: #8ac6f2; font-weight: bold;">else</span> {
        maximum = z;
    }
} <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> (y &gt; z) {
    maximum = y;
} <span style="color: #8ac6f2; font-weight: bold;">else</span> {
    maximum = z;
}
</pre>


<p>
Some long chains of if-then-else clauses can be simplified by using a "switch"
statement.  "switch" is appropriate only if every condition tests whether a
variable x is equal to some constant.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">switch</span> (month) {        |      <span style="color: #8ac6f2; font-weight: bold;">if</span> (month == <span style="color: #ffa07a;">2</span>) {                         
<span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">2</span>:                 |        days = <span style="color: #ffa07a;">28</span>;                              
  days = <span style="color: #ffa07a;">28</span>;            |      } <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> ((month == <span style="color: #ffa07a;">4</span>) || (month == <span style="color: #ffa07a;">6</span>) ||
  <span style="color: #8ac6f2; font-weight: bold;">break</span>;                |                 (month == <span style="color: #ffa07a;">9</span>) || (month == <span style="color: #ffa07a;">11</span>)) {
<span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">4</span>:                 |        days = <span style="color: #ffa07a;">30</span>;                              
<span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">6</span>:                 |      } <span style="color: #8ac6f2; font-weight: bold;">else</span> {                                  
<span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">9</span>:                 |        days = <span style="color: #ffa07a;">31</span>;                              
<span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">11</span>:                |      }                                         
  days = <span style="color: #ffa07a;">30</span>;            |
  <span style="color: #8ac6f2; font-weight: bold;">break</span>;
<span style="color: #8ac6f2; font-weight: bold;">default</span>:
  days = <span style="color: #ffa07a;">31</span>;
  <span style="color: #8ac6f2; font-weight: bold;">break</span>;
}                   <span style="color: #99968b;">//  </span><span style="color: #99968b;">These two code fragments do exactly the same thing.</span>
</pre>


<p>
IMPORTANT:  "break" jumps to the end of the "switch" statement.  If you forget
a break statement, the flow of execution will continue right through past the
next "case" clause, which is why cases 4, 6, and 9 work right.  If month == 12
in the following example, both Strings are printed.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">switch</span> (month) {
<span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">12</span>:
    output(<span style="color: #95e454;">"It's December."</span>);
    <span style="color: #99968b;">// </span><span style="color: #99968b;">Just keep moving right on through.</span>
<span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">1</span>:
<span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">2</span>:
<span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">11</span>:
    output(<span style="color: #95e454;">"It's cold."</span>);
}
</pre>


<p>
However, this is considered bad style, because it's hard to read and
understand.  If there's any chance that other people will need to read or
modify your code (which is the norm when you program for a business), don't
code it like this.  Use break statements in the switch, and use subroutines to
reuse code and clarify the control flow.
</p>
<p>
Observe that the last example doesn't have a "default:" case.  If "month" is
not 1 nor 2 nor 11 nor 12, Java jumps right to the end of the "switch"
statement (just past the closing brace) and continues execution from there.
</p>
</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> THE "return" KEYWORD</h3>
<div class="outline-text-3" id="text-3-4">

<p>Like conditionals, "return" affects the flow of control of a program.  It
causes a method to end immediately, so that control returns to the calling
method.
</p>
<p>
Here's a recursive method that prints the numbers from 1 to x.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">oneToX</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">x</span>) {
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (x &lt; <span style="color: #ffa07a;">1</span>) {
        <span style="color: #8ac6f2; font-weight: bold;">return</span>;
    }
    oneToX(x - <span style="color: #ffa07a;">1</span>);
    System.out.println(x);
}
</pre>


<p>
The return keyword serves a dual purpose:  it is also the means by which a
function returns a value.  A <span style="text-decoration:underline;">function</span> is a method that is declared to return
a non-void type.  For instance, here's a function that returns an int.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">daysInMonth</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">month</span>) {
    <span style="color: #8ac6f2; font-weight: bold;">switch</span> (month) {
    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">2</span>:
        <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #ffa07a;">28</span>;
    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">4</span>:
    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">6</span>:
    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">9</span>:
    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #ffa07a;">11</span>:
        <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #ffa07a;">30</span>;
    <span style="color: #8ac6f2; font-weight: bold;">default</span>:
        <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #ffa07a;">31</span>;
    }
}
</pre>


<p>
The "return" value can be an expression.  Some examples:
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">return</span> x + y - z;

<span style="color: #8ac6f2; font-weight: bold;">return</span> car.velocity(time);
</pre>

</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Lecture 5</h2>
<div class="outline-text-2" id="text-4">

<p>Today's reading:  Sierra &amp; Bates pp. 59-62, 83, 114-116, 293-300, 670.
</p>
</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> LOOPS</h3>
<div class="outline-text-3" id="text-4-1">


</div>

<div id="outline-container-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> "while" Loops</h4>
<div class="outline-text-4" id="text-4-1-1">

<p>A "while" statement is like an "if" statement, but the body of the statement is
executed repeatedly, as long as the condition remains true.  The following
example tests whether n is a prime number by attempting to divide it by every
integer in the range 2&hellip;n - 1.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">boolean</span> <span style="color: #cae682;">isPrime</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">n</span>) {
  <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">divisor</span> = <span style="color: #ffa07a;">2</span>;
  <span style="color: #8ac6f2; font-weight: bold;">while</span> (divisor &lt; n) {         <span style="color: #7fffd4;">_</span> &lt;- <span style="color: #95e454;">"divisor &lt; n"</span> is the _loop_condition_.
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (n % divisor == <span style="color: #ffa07a;">0</span>) {      |
      <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #7fffd4;">false</span>;              | These lines inside the braces
    }                            | are called the _loop_body_.  
    divisor++;                  <span style="color: #7fffd4;">_</span>|
  }
  <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #7fffd4;">true</span>;
}
</pre>


<p>
Here's how the loop executes.
</p><ul>
<li>When Java reaches this "while" loop, it tests whether the loop condition
  "divisor &lt; n" is true.
</li>
<li>If divisor &lt; n, Java executes the loop body {in braces}.
</li>
<li>When Java finishes the loop body (i.e. after executing "divisor++"), it
  tests <span style="text-decoration:underline;">again</span> whether "divisor &lt; n" is true.
</li>
<li>If it's still true, Java jumps back up to the beginning of the loop body and
  executes it again.
</li>
<li>If Java tests the loop condition and finds that "divisor &lt; n" is false, Java
  continues execution from the next line of code <span style="text-decoration:underline;">after</span> the loop body.
</li>
</ul>


<p>
An <span style="text-decoration:underline;">iteration</span> is a pass through the loop body.  In this example, if n is 2 or
less, the loop body won't iterate even once.
</p>
</div>

</div>

<div id="outline-container-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> "for" Loops</h4>
<div class="outline-text-4" id="text-4-1-2">

<p>"for" loops are a convenient shorthand that can be used to write some "while"
loops in a more compact way.  The following "for" loop is equivalent to the
following "while" loop.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">for</span> (initialize; condition; next) {      |    initialize;   
  statements;                            |    <span style="color: #8ac6f2; font-weight: bold;">while</span> (condition) {
}                                        |      statements;
                                         |      next;
                                         |    }
</pre>


<p>
By convention, the "initialize" and "next" are both expressions that affect a
variable that changes every loop iteration and is central to the test.  Most
commonly, "for" statements are used to iterate while advancing an index
variable over a fixed range of values.  isPrime can be rewritten thus:
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">boolean</span> <span style="color: #cae682;">isPrime</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">n</span>) {
  <span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">divisor</span> = <span style="color: #ffa07a;">2</span>; divisor &lt; n; divisor++) {    <span style="color: #7fffd4;">_</span>
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (n % divisor == <span style="color: #ffa07a;">0</span>) {                           |
      <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #7fffd4;">false</span>;                                   | Loop body.
    }                                                <span style="color: #7fffd4;">_</span>|
  }
  <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #7fffd4;">true</span>;
}
</pre>


<p>
A common mistake among beginning Java and C programmers is to get the condition
wrong and do one loop iteration too few.  For example, suppose you want to
print all the prime numbers in the range 2&hellip;n.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">printPrimes</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">n</span>) {
  <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span>;
  <span style="color: #8ac6f2; font-weight: bold;">for</span> (i = <span style="color: #ffa07a;">2</span>; i &lt; n; i++) {        <span style="color: #99968b;">// </span><span style="color: #99968b;">ERROR!!!  Condition should be i &lt;= n.</span>
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (isPrime(i)) {
      System.out.print(<span style="color: #95e454;">" "</span> + i);
    }
  }
}
</pre>


<p>
Suppose we correct this method so the loop condition is "i &lt;= n".  Think
carefully:  what is the value of i when the printPrimes method ends?
</p>
<p>
We'll come back to iteration, but first let's investigate something more
interesting to iterate on.
</p>
</div>
</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> ARRAYS</h3>
<div class="outline-text-3" id="text-4-2">

<p>An array is an object consisting of a numbered list of variables, each of which
is a primitive type or a reference to another object.  The variables in an
array are always indexed from zero in increments of one.  For example, here is
an array of characters.
</p>
<p>
<img src="ditaa-images/img20_f18bbd524ca86827357f5a81eda9dc5b05d7e38e.png"  alt="ditaa-images/img20_f18bbd524ca86827357f5a81eda9dc5b05d7e38e.png" />
</p>

<p>
Like any object, an array is only useful if we can reference it, usually
through some reference variable like "c" above.  We declare c thusly:
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">char</span>[] <span style="color: #cae682;">c</span>;           <span style="color: #99968b;">// </span><span style="color: #99968b;">Reference to an array (of any length) of characters.</span>
</pre>


<p>
We can construct an array of four characters as follows.
</p>



<pre class="src src-java">c = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">char</span>[<span style="color: #ffa07a;">4</span>];
</pre>


<p>
Now that we have an array object, we may fill in its values by indexing c.
</p>



<pre class="src src-java">c[<span style="color: #ffa07a;">0</span>] = <span style="color: #95e454;">'b'</span>;         <span style="color: #99968b;">// </span><span style="color: #99968b;">Store the character 'b' at index 0.</span>
c[<span style="color: #ffa07a;">1</span>] = <span style="color: #95e454;">'l'</span>;
c[<span style="color: #ffa07a;">2</span>] = <span style="color: #95e454;">'u'</span>;
c[<span style="color: #ffa07a;">3</span>] = <span style="color: #95e454;">'e'</span>;
</pre>


<p>
The characters in a four-element array are indexed from 0 to 3.  If we try to
address any index outside this range, we will trigger a run-time error.
</p>



<pre class="src src-java">c[<span style="color: #ffa07a;">4</span>] = <span style="color: #95e454;">'s'</span>;         <span style="color: #99968b;">// </span><span style="color: #99968b;">Program stops with ArrayIndexOutOfBoundsException</span>
</pre>


<p>
A <span style="text-decoration:underline;">run-time error</span> is an error that doesn't show up when you compile the code,
but does show up later when you run the program and the Java Virtual Machine
tries to access the out-of-range index.
</p>
<p>
When c references an array, you can find out its length by looking at the field
"c.length".  You can never assign a value to the "length" field, though.  Java
will give you a compile-time error if you try.
</p>
</div>

</div>

<div id="outline-container-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Primes Revisited</h3>
<div class="outline-text-3" id="text-4-3">


<p>
The printPrimes method is embarrassingly slow when n is large.  Arrays can help
us write a faster method to identify the primes from 2 to n.
</p>
<p>
The method uses an ancient algorithm called the Sieve of Eratosthenes.  All
integers are assumed prime until proven composite.  The algorithm iterates
through all possible divisors, and marks as non-prime every integer divisible
by a given divisor.  Here's the beginning of the method.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">printPrimes</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">n</span>) {
    <span style="color: #92a65e; font-weight: bold;">boolean</span>[] <span style="color: #cae682;">prime</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">boolean</span>[n + <span style="color: #ffa07a;">1</span>];                  <span style="color: #99968b;">// </span><span style="color: #99968b;">Numbered 0...n.</span>
    <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span>;
    <span style="color: #8ac6f2; font-weight: bold;">for</span> (i = <span style="color: #ffa07a;">2</span>; i &lt;= n; i++) {
        prime[i] = <span style="color: #7fffd4;">true</span>;                       <span style="color: #99968b;">// </span><span style="color: #99968b;">Prime until proven composite.</span>
    }
</pre>


<p>
Why did we construct an array of length n + 1?  Because if we'd constructed an
array of length n, its elements would be numbered from 0 to n - 1.  But we'd
like to have an element numbered n.
</p>
<p>
To continue the method, we iterate over all possible divisors from 2 to the
square root of n.  For each prime value of divisor, we mark as non-prime all
integers divisible by divisor, except divisor itself.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">divisor</span> = <span style="color: #ffa07a;">2</span>; divisor * divisor &lt;= n; divisor++) {
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (prime[divisor]) {
        <span style="color: #8ac6f2; font-weight: bold;">for</span> (i = <span style="color: #ffa07a;">2</span> * divisor; i &lt;= n; i = i + divisor) {
            prime[i] = <span style="color: #7fffd4;">false</span>;                     <span style="color: #99968b;">// </span><span style="color: #99968b;">i is divisible by divisor.</span>
        }
    }
}
</pre>


<p>
Math question:  why do we only need to consider divisors up to the square root
of n?
</p>
<p>
Finally, we print every integer from 2 to n that hasn't been marked non-prime.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">for</span> (i = <span style="color: #ffa07a;">2</span>; i &lt;= n; i++) {
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (prime[i]) {
        System.out.print(<span style="color: #95e454;">" "</span> + i);
    }
}
</pre>


<p>
Observe that elements 0 and 1 of the array are never used.  A tiny bit of
memory is wasted, but the readability of the code is better for it.
</p>
</div>

</div>

<div id="outline-container-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Multi-Dimensional Arrays</h3>
<div class="outline-text-3" id="text-4-4">

<p>A <span style="text-decoration:underline;">two-dimensional array</span> is an array of references to arrays.  A three-
dimensional array is an array of arrays of arrays.  As an example, consider
Pascal's Triangle.
</p>



<pre class="src src-texta">               1                  &lt;-- row 0
            1     1
         1     2     1
      1     3     3     1
   1     4     6     4     1
1     5    10     10    5     1   &lt;-- row 5
</pre>


<p>
Each entry is the sum of the two nearest entries in the row immediately above.
If the rows are numbered from zero, row i represents the coefficients of the
polynomial (x + 1)<sup>i</sup>.  For example, (x + 1)<sup>4</sup> = x<sup>4</sup> + 4x<sup>3</sup> + 6x<sup>2</sup> + 4x + 1.
</p>
<p>
The following method returns an array of arrays of ints that stores the first n
rows of Pascal's Triangle.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">int</span>[][] <span style="color: #cae682;">pascalTriangle</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">n</span>) {
    <span style="color: #92a65e; font-weight: bold;">int</span>[][] <span style="color: #cae682;">pt</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">int</span>[n][];
</pre>


<p>
Here, we've just declared pt to reference an array of arrays, and constructed
an array for it to reference.  However, the arrays that this array will
reference do not yet exist.  They are constructed and filled in by the
following loop.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span> = <span style="color: #ffa07a;">0</span>; i &lt; n; i++) {
    pt[i] = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">int</span>[i + <span style="color: #ffa07a;">1</span>];                            <span style="color: #99968b;">// </span><span style="color: #99968b;">Construct row i.</span>
    pt[i][<span style="color: #ffa07a;">0</span>] = <span style="color: #ffa07a;">1</span>;                              <span style="color: #99968b;">// </span><span style="color: #99968b;">Leftmost value of row i.</span>
    <span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">j</span> = <span style="color: #ffa07a;">1</span>; j &lt; i; j++) {
        pt[i][j] = pt[i - <span style="color: #ffa07a;">1</span>][j - <span style="color: #ffa07a;">1</span>] + pt[i - <span style="color: #ffa07a;">1</span>][j];  <span style="color: #99968b;">// </span><span style="color: #99968b;">Sum 2 entries above.</span>
    }
    pt[i][i] = <span style="color: #ffa07a;">1</span>;                             <span style="color: #99968b;">// </span><span style="color: #99968b;">Rightmost value of row i.</span>
}
<span style="color: #8ac6f2; font-weight: bold;">return</span> pt;
</pre>


<p>
Our array objects look like this:
</p>

<p>
<img src="ditaa-images/img22_3482f51d01f34c2b6cddbd547f7f69e8876a9d77.png"  alt="ditaa-images/img22_3482f51d01f34c2b6cddbd547f7f69e8876a9d77.png" />
</p>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Lecture 6</h2>
<div class="outline-text-2" id="text-5">

<p>Today's reading:  Sierra &amp; Bates pp. 282-285.
</p>
</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> MORE ARRAYS</h3>
<div class="outline-text-3" id="text-5-1">

</div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Automatic Array Construction</h3>
<div class="outline-text-3" id="text-5-2">

<p>Last lecture, we used a loop to construct all the arrays that the top-level
array references.  This was necessary to construct a triangular array.  But if
you want a rectangular multi-dimensional array, rather than a triangular one,
Java can construct all of the arrays for you at once.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">int</span>[][] <span style="color: #cae682;">table</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">int</span>[x][y];
</pre>


<p>
This declaration constructs an array of x references to arrays.  It also
constructs x arrays of y ints.  The variable "table" references the array of
arrays; and each entry in the array of arrays references one of the arrays of
ints.  All the arrays are constructed for you at once.  Similarly, Java can
construct three- or ten-dimensional arrays for you, memory permitting.
</p>
<p>
We could have used a square array to store Pascal's Triangle, but that would
have unnecessarily wasted memory.  If you have enough memory, you might not
care.
</p>
<p>
When you declare a variable, you can also construct array entries by using
initializers.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">Human</span>[] <span style="color: #cae682;">b</span> = {amanda, rishi, <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">Human</span>(<span style="color: #95e454;">"Paolo"</span>)};
<span style="color: #92a65e; font-weight: bold;">int</span>[][] <span style="color: #cae682;">c</span> = {{<span style="color: #ffa07a;">7</span>, <span style="color: #ffa07a;">3</span>, <span style="color: #ffa07a;">2</span>}, {x}, {<span style="color: #ffa07a;">8</span>, <span style="color: #ffa07a;">5</span>, <span style="color: #ffa07a;">0</span>, <span style="color: #ffa07a;">0</span>}, {y + z, <span style="color: #ffa07a;">3</span>}};
</pre>


<p>
In the second example, Java constructs a non-rectangular two-dimensional array,
composed of one array of arrays and four arrays of ints.
</p>
<p>
Sadly, you can only use this notation in a declaration.  You can't write
</p>



<pre class="src src-java">d = {<span style="color: #ffa07a;">3</span>, <span style="color: #ffa07a;">7</span>};                  <span style="color: #99968b;">// </span><span style="color: #99968b;">Compile-time ERROR.</span>
f({<span style="color: #ffa07a;">1</span>, <span style="color: #ffa07a;">2</span>, <span style="color: #ffa07a;">3</span>});                <span style="color: #99968b;">// </span><span style="color: #99968b;">Compile-time ERROR.</span>
</pre>


<p>
Another subtlety of array declarations is the following.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">int</span>[] <span style="color: #cae682;">a</span>, <span style="color: #cae682;">b</span>, <span style="color: #cae682;">c</span>;                           <span style="color: #99968b;">// </span><span style="color: #99968b;">a, b, and c all reference arrays.</span>
<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">a</span>[], <span style="color: #cae682;">b</span>, <span style="color: #cae682;">c</span>[][];           <span style="color: #99968b;">// </span><span style="color: #99968b;">a is 1D; c is 2D; b is not a reference/array.</span>
<span style="color: #92a65e; font-weight: bold;">int</span>[] <span style="color: #cae682;">a</span>, <span style="color: #cae682;">b</span>[];            <span style="color: #99968b;">// </span><span style="color: #99968b;">a references a 1D array; b references a 2D array.</span>
</pre>


<p>
Arrays of Objects

</p>
<hr/>
<p>
When you construct a multi-dimensional array, Java can construct all the arrays
for you.  But when you construct an array of objects, Java does not construct
the objects automatically.  The array contains space for references to the
objects.  You must construct the objects yourself.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">String</span>[] <span style="color: #cae682;">sentence</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">String</span>[<span style="color: #ffa07a;">3</span>];
sentence[<span style="color: #ffa07a;">0</span>] = <span style="color: #95e454;">"Word"</span>;
sentence[<span style="color: #ffa07a;">2</span>] = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">String</span>();
</pre>



<p>
<img src="ditaa-images/TEMP_1_68926540f9653ecb7f25815a4e3e7c95190e99dc.png"  alt="ditaa-images/TEMP_1_68926540f9653ecb7f25815a4e3e7c95190e99dc.png" />
</p>

<p>
main()'s Parameter

</p>
<hr/>
<p>
What is the array of Strings that the main() method takes as a parameter?
It's a list of command-line arguments sent to your Java program, prepared for
you by Java.  Consider the following program.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">Echo</span> {
  <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">main</span>(<span style="color: #92a65e; font-weight: bold;">String</span>[] <span style="color: #cae682;">args</span>) {
    <span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span> = <span style="color: #ffa07a;">0</span>; i &lt; args.length; i++) {
      System.out.println(args[i]);
    }
  }
}
</pre>


<p>
If we compile this and type "java Echo kneel and worship Java", java prints
</p>

<p>
<img src="ditaa-images/TEMP_2_510aaafcf043f928583ecbe7b35d73e07475d85f.png"  alt="ditaa-images/TEMP_2_510aaafcf043f928583ecbe7b35d73e07475d85f.png" />
</p>
</div>

</div>

<div id="outline-container-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> MORE LOOPS</h3>
<div class="outline-text-3" id="text-5-3">


</div>

<div id="outline-container-5-3-1" class="outline-4">
<h4 id="sec-5-3-1"><span class="section-number-4">5.3.1</span> "do" Loops</h4>
<div class="outline-text-4" id="text-5-3-1">

<p>A "do" loop has just one difference from a "while" loop.  If Java reaches
a "do" loop, it <span style="text-decoration:underline;">always</span> executes the loop body at least once.  Java doesn't
check the loop condition until the end of the first iteration.  "do" loops are
appropriate for any loop you always want executed at least once, especially if
the variables in the condition won't have meaningful assignments until the loop
body has been executed.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">do</span> {
  s = keybd.readLine();
  process(s);
} <span style="color: #8ac6f2; font-weight: bold;">while</span> (s.length() &gt; <span style="color: #ffa07a;">0</span>);               <span style="color: #99968b;">// </span><span style="color: #99968b;">Exit loop if s is an empty String.</span>
</pre>


</div>

</div>

<div id="outline-container-5-3-2" class="outline-4">
<h4 id="sec-5-3-2"><span class="section-number-4">5.3.2</span> The "break" and "continue" Statements</h4>
<div class="outline-text-4" id="text-5-3-2">


<p>
A "break" statement immediately exits the innermost loop or "switch" statement
enclosing the "break", and continues execution at the code following the loop
or "switch".
</p>
<p>
In the loop example above, we might want to skip "process(s)" when s is a
signal to exit (in this case, an empty String).  We want a "time-and-a-half"
loop&ndash;we want to enter the loop at a different point in the read-process cycle
than we want to exit the loop at.  Here are two alternative loops that do the
right thing.  They behave identically.  Each has a different disadvantage.
</p>



<pre class="src src-java">  s = keybd.readLine();                  |  <span style="color: #8ac6f2; font-weight: bold;">while</span> (<span style="color: #7fffd4;">true</span>) {       <span style="color: #99968b;">// </span><span style="color: #99968b;">Loop forever.</span>
  <span style="color: #8ac6f2; font-weight: bold;">while</span> (s.length() &gt; <span style="color: #ffa07a;">0</span>) {               |    s = keybd.readLine();
    process(s);                          |    <span style="color: #8ac6f2; font-weight: bold;">if</span> (s.length() == <span style="color: #ffa07a;">0</span>) {      
    s = keybd.readLine();                |      <span style="color: #8ac6f2; font-weight: bold;">break</span>;
  }                                      |    }                           
                                         |    process(s);
                                         |}
<span style="color: #99968b;">/*</span><span style="color: #99968b;">Disadvantage:  The line "s = keybd..." |</span>
<span style="color: #99968b;">is repeated twice.  It's not really      |</span>
<span style="color: #99968b;">a disadvantage here, but if input        | Disadvantage:  Somewhat obfuscated for </span>
<span style="color: #99968b;">took 100 lines of code, the              | the reader, because the loop isn't </span>
<span style="color: #99968b;">duplication would make the code harder   | aligned with its natural endpoint. </span>
<span style="color: #99968b;">to maintain.  Why?  Because a </span>
<span style="color: #99968b;">programmer improving the code might change one copy of the duplicated code </span>
<span style="color: #99968b;">without noticing the need to change the other to match.*/</span>
</pre>


<p>
Some loops have more than one natural endpoint.  Suppose we want to iterate the
read-process loop at most ten times.  In the example at left below, the "break"
statement cannot be criticized, because the loop has two natural endpoints.  We
could get rid of the "break" by writing the loop as at right below, but the
result is longer and harder to read.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span> = <span style="color: #ffa07a;">0</span>; i &lt; <span style="color: #ffa07a;">10</span>; i++) {       |  <span style="color: #92a65e; font-weight: bold;">int</span> i = <span style="color: #ffa07a;">0</span>;
  s = keybd.readLine();              |  <span style="color: #8ac6f2; font-weight: bold;">do</span> {
  <span style="color: #8ac6f2; font-weight: bold;">if</span> (s.length() == <span style="color: #ffa07a;">0</span>) {             |    s = keybd.readLine();       
    <span style="color: #8ac6f2; font-weight: bold;">break</span>;                           |    <span style="color: #8ac6f2; font-weight: bold;">if</span> (s.length() &gt; <span style="color: #ffa07a;">0</span>) {             
  }                                  |      process(s);                      
  process(s);                        |    }
}                                    |    i++;
                                     |  } <span style="color: #8ac6f2; font-weight: bold;">while</span> ((i &lt; <span style="color: #ffa07a;">10</span>) &amp;&amp;
                                     |           (s.length() &gt; <span style="color: #ffa07a;">0</span>));
</pre>


<p>
There are anti-break zealots who claim that the loop on the right is the
"correct" way to do things.  I disagree, because the left loop is clearly more
readable.
</p>
<p>
Some of the zealots feel this way because "break" statements are a little bit
like the "go to" statements found in some languages like Basic and Fortran (and
the machine language that microprocessors really execute).  "go to" statements
allow you to jump to any line of code in the program.  It sounds like a good
idea at first, but it invariably leads to insanely unmaintainable code.  For
example, what happens if you jump to the middle of a loop?  Turing Award winner
Edsger Dijkstra wrote a famous article in 1968 entitled "Go To Statement
Considered Harmful", which is part of the reason why many modern languages like
Java don't have "go to" statements.
</p>
<p>
Both "break" and "return" are limited forms of "go to" statements.  Their
limitations prohibit the worst abuses of "go to".  They allow control flow to
jump in your program in ways that are straightforward to understand.
</p>
<p>
WARNING:  It's easy to forget exactly where a "break" statement will jump to.
For example, "break" does not jump to the end of the innermost enclosing "if"
statement.  An AT&amp;T programmer introduced a bug into telephone switching
software in a procedure that contained a "switch" statement, which contained an
"if" clause, which contained a "break", which was intended for the "if" clause,
but instead jumped to the end of the "switch" statement.  As a result, on
January 15, 1990, AT&amp;T's entire U.S. long distance service collapsed for eleven
hours.  (That code was actually written in C, but Java and C use identical
syntax and semantics for loops, "switch", and "break".)
</p>
<p>
The "continue" statement is akin to the "break" statement, except
(1) it only applies to loops, and
(2) it jumps to the end of the loop body but it doesn't necessarily exit the
    loop; another iteration will commence if the loop condition is satisfied.
</p>
<p>
Finally, I told you that "for" loops are identical to certain "while" loops,
but there's actually a subtle difference when you use "continue".  What's the
difference between the following two loops?
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span> = <span style="color: #ffa07a;">0</span>;                           | <span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span> = <span style="color: #ffa07a;">0</span>; i &lt; <span style="color: #ffa07a;">10</span>; i++) {
<span style="color: #8ac6f2; font-weight: bold;">while</span> (i &lt; <span style="color: #ffa07a;">10</span>) {                     |   <span style="color: #8ac6f2; font-weight: bold;">if</span> (condition(i)) {
  <span style="color: #8ac6f2; font-weight: bold;">if</span> (condition(i)) {                |     <span style="color: #8ac6f2; font-weight: bold;">continue</span>;
    <span style="color: #8ac6f2; font-weight: bold;">continue</span>;                        |   }
  }                                  |   call(i);
  call(i);                           | }
  i++;                               |
}                                    |
</pre>


<p>
Answer:  when "continue" is called in the "while" loop, "i++" is not executed.
In the "for" loop, however, i is incremented at the end of <span style="text-decoration:underline;">every</span> iteration,
even iterations where "continue" is called.
</p>
</div>
</div>

</div>

<div id="outline-container-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> CONSTANTS</h3>
<div class="outline-text-3" id="text-5-4">


<p>
Java's "final" keyword is used to declare a value that can never be changed.
If you find yourself repeatedly using a numerical value with some "meaning" in
your code, you should probably turn it into a "final" constant.
</p>



<pre class="src src-java"><span style="color: #e5786d;">BAD</span>:     <span style="color: #8ac6f2; font-weight: bold;">if</span> (month == <span style="color: #ffa07a;">2</span>) {

<span style="color: #e5786d;">GOOD</span>:    <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">final</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">FEBRUARY</span> = <span style="color: #ffa07a;">2</span>;    <span style="color: #99968b;">// </span><span style="color: #99968b;">Usually near top of class.</span>

         ...

         <span style="color: #8ac6f2; font-weight: bold;">if</span> (month == <span style="color: #7fffd4;">FEBRUARY</span>) {
</pre>


<p>
Why?  Because if you ever need to change the numerical value assigned to
February, you'll only have to change one line of code, rather than hundreds.
</p>
<p>
You can't change the value of FEBRUARY after it is declared and initialized.
If you try to assign another value to FEBRUARY, you'll have a compiler error.
</p>
<p>
The custom of rendering constants in all-caps is long-established and was
inherited from C.  (The compiler does not require it, though.)
</p>
<p>
For any array x, "x.length" is a "final" field.
</p>
<p>
You can declare local parameters "final" to prevent them from being changed.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">myMethod</span>(<span style="color: #b0c4de;">final</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">x</span>) {
  x = <span style="color: #ffa07a;">3</span>;                             <span style="color: #99968b;">// </span><span style="color: #99968b;">Compiler ERROR.  Don't mess with X's!</span>
}
</pre>


<p>
"final" is usually used for class variables (static fields) and parameters, but
it can be used for instance variables (non-static fields) and local variables
too.  It only makes sense for these to be "final" if the variable is declared
with an initializer that calls a method or constructor that doesn't always
return the same value.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">Bob</span> {
  <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">final</span> <span style="color: #92a65e; font-weight: bold;">long</span> <span style="color: #cae682;">creationTime</span> = System.currentTimeMillis();
}
</pre>


<p>
When objects of the Bob class are constructed, they record the time at that
moment.  Afterward, the creationTime can never be changed.
</p>
</div>

</div>

<div id="outline-container-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> SCOPE</h3>
<div class="outline-text-3" id="text-5-5">


<p>
The <span style="text-decoration:underline;">scope</span> of a variable is the portion of the program that can access the
variable.  Here are some of Java's scoping rules.
</p>
<ul>
<li>Local variables and parameters are in scope only inside the method that
  declares them.  Furthermore, a local variable is in scope only from the
  variable declaration down to the innermost closing brace that encloses it.
  A local variable declared in the initialization part of a "for" loop is in
  scope only in the loop body.
</li>
<li>Class variables (static fields) are in scope everywhere in the class,
  except when shadowed by a local variable or parameter of the same name.
</li>
<li>Instance variables (non-static fields) are in scope in non-static methods
  of the class, except when shadowed.
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Lecture 7</h2>
<div class="outline-text-2" id="text-6">

<p>Today's reading:  Goodrich &amp; Tamassia, Section 3.2.
</p>
</div>

<div id="outline-container-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> LISTS</h3>
<div class="outline-text-3" id="text-6-1">

<p>Let's consider two different data structures for storing a list of things:
an array and a linked list.
</p>
<p>
An array is a pretty obvious way to store a list, with a big advantage:  it
enables very fast access of each item.  However, it has two disadvantages.
</p>
<p>
First, if we want to insert an item at the beginning or middle of an array, we
have to slide a lot of items over one place to make room.  This takes time
proportional to the length of the array.
</p>
<p>
Second, an array has a fixed length that can't be changed.  If we want to add
items to the list, but the array is full, we have to allocate a whole new array
and move all the ints from the old array to the new one.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">AList</span> {
  <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">a</span>[];
  <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">lastItem</span>;

  <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">AList</span>() {
    a = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">int</span>[<span style="color: #ffa07a;">10</span>];                           <span style="color: #99968b;">// </span><span style="color: #99968b;">The number "10" is arbitrary.</span>
    lastItem = -<span style="color: #ffa07a;">1</span>;
  }

  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">insertItem</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">newItem</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">location</span>) {
    <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span>;

    <span style="color: #8ac6f2; font-weight: bold;">if</span> (lastItem + <span style="color: #ffa07a;">1</span> == a.length) {               <span style="color: #99968b;">// </span><span style="color: #99968b;">No room left in the array?</span>
      <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">b</span>[] = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">int</span>[<span style="color: #ffa07a;">2</span> * a.length];  <span style="color: #99968b;">// </span><span style="color: #99968b;">Allocate a new array, twice as long.</span>
      <span style="color: #8ac6f2; font-weight: bold;">for</span> (i = <span style="color: #ffa07a;">0</span>; i &lt;= lastItem; i++) {      <span style="color: #99968b;">// </span><span style="color: #99968b;">Copy items to the bigger array.</span>
        b[i] = a[i];
      }
      a = b;                   <span style="color: #99968b;">// </span><span style="color: #99968b;">Replace the too-small array with the new one.</span>
    }
    <span style="color: #8ac6f2; font-weight: bold;">for</span> (i = lastItem; i &gt;= location; i--) {       <span style="color: #99968b;">// </span><span style="color: #99968b;">Shift items to the right.</span>
      a[i + <span style="color: #ffa07a;">1</span>] = a[i];
    }
    a[location] = newItem;
    lastItem++;
  }
}
</pre>


</div>

</div>

<div id="outline-container-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> LINKED LISTS (a recursive data type)</h3>
<div class="outline-text-3" id="text-6-2">

<p>We can avoid these problems by choosing a Scheme-like representation of lists.
A linked list is made up of <span style="text-decoration:underline;">nodes</span>.  Each node has two components:  an item,
and a reference to the next node in the list.  These components are analogous
to "car" and "cdr".  However, our node is an explicitly defined object.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">ListNode</span> {          <span style="color: #99968b;">// </span><span style="color: #99968b;">ListNode is a recursive type</span>
  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">item</span>;
  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">ListNode</span> <span style="color: #cae682;">next</span>;          <span style="color: #99968b;">// </span><span style="color: #99968b;">Here we're using ListNode before</span>
}                                <span style="color: #99968b;">//   </span><span style="color: #99968b;">we've finished declaring it.</span>
</pre>


<p>
Let's make some ListNodes.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">ListNode</span> <span style="color: #cae682;">l1</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">ListNode</span>(), <span style="color: #cae682;">l2</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">ListNode</span>(), <span style="color: #cae682;">l3</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">ListNode</span>();
l1.item = <span style="color: #ffa07a;">7</span>;
l2.item = <span style="color: #ffa07a;">0</span>;
l3.item = <span style="color: #ffa07a;">6</span>;
</pre>



<p>
<img src="ditaa-images/img1_37c2298e59fd3fe495e84ff51de8be20f174e97e.png"  alt="ditaa-images/img1_37c2298e59fd3fe495e84ff51de8be20f174e97e.png" />
</p>
<p>
Now let's link them together.
</p>



<pre class="src src-java">l1.next = l2;
l2.next = l3;
</pre>


<p>
What about the last node?  We need a reference that doesn't reference anything.
In Java, this is called "null".
</p>



<pre class="src src-java">l3.next = <span style="color: #7fffd4;">null</span>;
</pre>



<p>
<img src="ditaa-images/img2_43021c3bd54ee1e1e24162b47c8feaaa105fe7e7.png"  alt="ditaa-images/img2_43021c3bd54ee1e1e24162b47c8feaaa105fe7e7.png" />
</p>

<p>
To simplify programming, let's add some constructors to the ListNode class.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">ListNode</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span>, <span style="color: #92a65e; font-weight: bold;">ListNode</span> <span style="color: #cae682;">n</span>) {
  item = i;
  next = n;
}

<span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">ListNode</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span>) {
  <span style="color: #8ac6f2; font-weight: bold;">this</span>(i, <span style="color: #7fffd4;">null</span>);
}
</pre>


<p>
These constructors allow us to emulate Scheme's "cons" operation.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">ListNode</span> <span style="color: #cae682;">l1</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">ListNode</span>(<span style="color: #ffa07a;">7</span>, <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">ListNode</span>(<span style="color: #ffa07a;">0</span>, <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">ListNode</span>(<span style="color: #ffa07a;">6</span>)));
</pre>

</div>

</div>

<div id="outline-container-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Linked lists vs. array lists</h3>
<div class="outline-text-3" id="text-6-3">

<p>Linked lists have several advantages over array-based lists.  Inserting an item
into the middle of a linked list takes just a small constant amount of time, if
you already have a reference to the previous node (and don't have to walk
through the whole list searching for it).  The list can keep growing until
memory runs out.
</p>
<p>
The following method inserts a new item into the list immediately after "this".
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">insertAfter</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">item</span>) {
  next = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">ListNode</span>(item, next);
}

l2.insertAfter(<span style="color: #ffa07a;">3</span>);
</pre>



<p>
<img src="ditaa-images/img3_8e829be91e6e4c2a240073601aab1ee004ff6d58.png"  alt="ditaa-images/img3_8e829be91e6e4c2a240073601aab1ee004ff6d58.png" />
</p>

<p>
However, linked lists have a big disadvantage compared to arrays.  Finding the
nth item of an array takes a tiny, constant amount of time.  Finding the nth
item of a linked list takes time proportional to n.  You have to start at the
head of the list and walk forward n - 1 nodes, one "next" at a time.
</p>
<p>
Many of the data structures we will study in this class will be attempts to
find a compromise between arrays and linked lists.  We'll learn data structures
that are fast for both arbitrary lookups (like arrays) <span style="text-decoration:underline;">and</span> arbitrary
insertions (like linked lists).
</p>
</div>

</div>

<div id="outline-container-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> Lists of Objects</h3>
<div class="outline-text-3" id="text-6-4">


<p>
For greater generality, let's change ListNodes so that each node contains not
an int, but a reference to any Java object.  In Java, we can accomplish this by
declaring a reference of type Object.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">SListNode</span> {
  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">item</span>;
  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">SListNode</span> <span style="color: #cae682;">next</span>;
}
</pre>


<p>
The "S" in "SListNode" stands for singly-linked.  This will make sense when we
contrast these lists with doubly-linked lists later.  You'll see the SListNode
class in next week's lab and homework.
</p>
</div>

</div>

<div id="outline-container-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> A List Class</h3>
<div class="outline-text-3" id="text-6-5">


<p>
There are two problems with SListNodes.
</p>
<p>
(1)  Suppose x and y are pointers to the same shopping list.  Suppose we insert
     a new item at the beginning of the list thusly:
</p>


<pre class="src src-java">x = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">SListNode</span>(<span style="color: #95e454;">"soap"</span>, x);
</pre>

<p>
     y doesn't point to the new item; y still points to the second item in x's
     list.  If y goes shopping for x, he'll forget to buy soap.
</p>
<p>
(2)  How do you represent an empty list?  The obvious way is "x = null".
     However, Java won't let you call a SListNode method&ndash;or any method&ndash;on
     a null object.  If you write "x.insertAfter(item)" when x is null, you'll
     get a run-time error, even though x is declared to be a SListNode.
     (There are good reasons for this, which you'll learn later in the course.)
</p>
<p>
The solution is a separate SList class, whose job is to maintain the head
(first node) of the list.  We will put many of the methods that operate on
lists in the SList class, rather than the SListNode class.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">SList</span> {
  <span style="color: #b0c4de;">private</span> <span style="color: #92a65e; font-weight: bold;">SListNode</span> <span style="color: #cae682;">head</span>;             <span style="color: #99968b;">// </span><span style="color: #99968b;">First node in list.</span>
  <span style="color: #b0c4de;">private</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">size</span>;                   <span style="color: #99968b;">// </span><span style="color: #99968b;">Number of items in list.</span>

  <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">SList</span>() {                    <span style="color: #99968b;">// </span><span style="color: #99968b;">Here's how to represent an empty list.</span>
    head = <span style="color: #7fffd4;">null</span>;
    size = <span style="color: #ffa07a;">0</span>;
  }

  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">insertFront</span>(<span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">item</span>) {
    head = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">SListNode</span>(item, head);
    size++;
  }
}
</pre>


<p>
<img src="ditaa-images/img4_db2f79dece321b6baa1e71ba2ecf93ea49dcbc0d.png"  alt="ditaa-images/img4_db2f79dece321b6baa1e71ba2ecf93ea49dcbc0d.png" />
</p>

<p>
Now, when you call x.insertFront("fish"), every reference to that SList can see
the change.
</p>

<p>
<img src="ditaa-images/img5_2073f5ca5ef1a31708f16ea8f036cc5fcb911471.png"  alt="ditaa-images/img5_2073f5ca5ef1a31708f16ea8f036cc5fcb911471.png" />
</p>

<p>
Another advantage of the SList class is that it can keep a record of the
SList's size (number of SListNodes).  Hence, the size can be determined more
quickly than if the SListNodes had to be counted.
</p></div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Lecture 8</h2>
<div class="outline-text-2" id="text-7">

<p>Today's reading:  Goodrich &amp; Tamassia, Section 3.3.
</p>
</div>

<div id="outline-container-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> THE "public" AND "private" KEYWORDS</h3>
<div class="outline-text-3" id="text-7-1">


<p>
Thus far, we've usually declared fields and methods using the "public" keyword.
However, we can also declare a field or method "private".  A private method
or field is invisible and inaccessible to other classes, and can be used only
within the class in which the field or method is declared.
</p>
<p>
Why would we want to make a field or method private?
</p><ol>
<li>To prevent data within an object from being corrupted by other classes.
</li>
<li>To ensure that you can improve the implementation of a class without
      causing other classes that depend on it to fail.
</li>
</ol>


<p>
In the following example, EvilTamperer tries to get around the error checking
code of the Date class by fiddling with the internals of a Date object.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">Date</span> {                  |  <span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> EvilTamperer {
  <span style="color: #b0c4de;">private</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">day</span>;                   |    <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> tamper() {
  <span style="color: #b0c4de;">private</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">month</span>;                 |      Date d = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">Date</span>(<span style="color: #ffa07a;">1</span>, <span style="color: #ffa07a;">1</span>, <span style="color: #ffa07a;">2006</span>);
                                     |
  <span style="color: #b0c4de;">private</span> <span style="color: #92a65e; font-weight: bold;">void</span> setMonth(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">m</span>) {     |      d.day = <span style="color: #ffa07a;">100</span>;    <span style="color: #99968b;">// </span><span style="color: #99968b;">Foiled!!</span>
    month = m;                       |      d.setMonth(<span style="color: #ffa07a;">0</span>);  <span style="color: #99968b;">// </span><span style="color: #99968b;">Foiled again!!</span>
  }                                  |    }
                                     |  }
  <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">Date</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">month</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">day</span>) {  |
    [Implementation with             |
     error-checking code here.]      |
  }
}
</pre>


<p>
However, javac won't compile EvilTamperer, because the Date class has declared
its vulnerable parts "private".  setMonth is an internal helper method used
within the Date class, whereas the Date constructor is a public part of the
interface of the Date class.  Error-checking code in the constructor ensures
that invalid Dates are not constructed.
</p>
<p>
Here are some important definitions.
</p>
<p>
The <span style="text-decoration:underline;">interface</span> of a class is a set of prototypes for public methods (and
sometimes public fields), plus descriptions of the methods' behaviors.
</p>
<p>
An <span style="text-decoration:underline;">Abstract Data Type</span> (ADT) is a class that has a well-defined interface, but
its implementation details are firmly hidden from other classes.  That way, you
can change the implementation of a class without jeopardizing the programs that
depend on it.  The Date class is an ADT.  We'll implement lots of ADTs this
semester.
</p>
<p>
An <span style="text-decoration:underline;">invariant</span> is a fact about a data structure that is always true (assuming
the code is bug-free), no matter what methods are called by external classes.
For example, the Date ADT enforces the invariant that a Date object always
represents a valid date.  An invariant is enforced by allowing access to
certain fields only through method calls.
</p>
<p>
An ADT is often a good thing to aspire to.  In most of your classes, you should
declare all fields private, as well as helper functions meant only for internal
use, so that you can maintain sensible invariants on your data structures.
</p>
<p>
However, not all classes are ADTs!  Some classes are nothing more than data
storage units, and do not need to enforce any invariants.  In such classes, all
fields may be declared public.
</p>
</div>

</div>

<div id="outline-container-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> The SList ADT</h3>
<div class="outline-text-3" id="text-7-2">

<p>Last lecture, I created an SList class to solve the problems of representing
empty lists and inserting items at the beginning of a list.  Today, I want to
introduce another advantage of the SList class.
</p>
<p>
We want the SList ADT to enforce two invariants:
</p><ol>
<li>An SList's "size" variable is always correct.
</li>
<li>A list is never circularly linked; there is always a tail node whose
     "next" reference is null.
</li>
</ol>


<p>
Both these goals are accomplished by making sure that <span style="text-decoration:underline;">only</span> the methods of the
SList class can change the lists' internal data structures.  SList ensures this
by two means:
</p><ol>
<li>The fields of the SList class (head and size) are declared "private".
</li>
<li>No method of SList returns an SListNode.
</li>
</ol>


<p>
The first rule is necessary so that the evil tamperer can't change the fields
and corrupt the SList or violate invariant (1).  The second rule prevents the
evil tamperer from changing list items, truncating a list, or creating a cycle
in a list, thereby violating invariant (2).
</p>
</div>

</div>

<div id="outline-container-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> DOUBLY-LINKED LISTS</h3>
<div class="outline-text-3" id="text-7-3">


<p>
As we saw last class, inserting an item at the front of a linked list is easy.
Deleting from the front of a list is also easy.  However, inserting or deleting
an item at the end of a list entails a search through the entire list, which
might take a long time.  (Inserting at the end is easy if you have a `tail'
pointer, as you will learn in Lab 3, but deleting is still hard.)
</p>
<p>
A doubly-linked list is a list in which each node has a reference to the
previous node, as well as the next node.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">DListNode</span> {                    |  <span style="color: #8ac6f2; font-weight: bold;">class</span> DList {
  <span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">item</span>;                       |    <span style="color: #b0c4de;">private</span> DListNode head;
  <span style="color: #92a65e; font-weight: bold;">DListNode</span> <span style="color: #cae682;">next</span>;                    |    <span style="color: #b0c4de;">private</span> DListNode tail;
  <span style="color: #92a65e; font-weight: bold;">DListNode</span> <span style="color: #cae682;">prev</span>;                    |  }
}                                    |
</pre>



<p>
<img src="ditaa-images/img6_cd5ba821016012cec703843d0a439384c1f64746.png"  alt="ditaa-images/img6_cd5ba821016012cec703843d0a439384c1f64746.png" />
</p>

<p>
DLists make it possible to insert and delete items at both ends of the list,
taking constant running time per insertion and deletion.  The following code
removes the tail node (in constant time) if there are at least two items in the
DList.
</p>



<pre class="src src-java">tail.prev.next = <span style="color: #7fffd4;">null</span>;
tail = tail.prev;
</pre>


<p>
You'll need a special case for a DList with no items.  You'll also need a
special case for a DList with one item, because tail.prev.next does not exist.
(Instead, head needs to be changed.)
</p>
<p>
Let's look at a clever trick for reducing the number of special cases, thereby
simplifying our DList code.  We designate one DListNode as a <span style="text-decoration:underline;">sentinel</span>, a
special node that does not represent an item.  Our list representation will be
circularly linked, and the sentinel will represent both the head and the tail
of the list.  Our DList class no longer needs a tail pointer, and the head
pointer points to the sentinel.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">DList</span> {
  <span style="color: #b0c4de;">private</span> <span style="color: #92a65e; font-weight: bold;">DListNode</span> <span style="color: #cae682;">head</span>;
  <span style="color: #b0c4de;">private</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">size</span>;
}
</pre>



<p>
<img src="ditaa-images/img7_555d53c4e74eec30c432fae3bea2966acc0091f2.png"  alt="ditaa-images/img7_555d53c4e74eec30c432fae3bea2966acc0091f2.png" />
</p>
<p>
The invariants of the DList ADT are more complicated than the SList invariants.
The following invariants apply to the DList with a sentinel.
</p><ol>
<li>For any DList d, d.head != null.  (There's always a sentinel.)
</li>
<li>For any DListNode x, x.next != null.
</li>
<li>For any DListNode x, x.prev != null.
</li>
<li>For any DListNode x, if x.next == y, then y.prev == x.
</li>
<li>For any DListNode x, if x.prev == y, then y.next == x.
</li>
<li>A DList's "size" variable is the number of DListNodes, NOT COUNTING the
     sentinel (denoted by "head"), that can be accessed from the sentinel by
     a sequence of "next" references.
</li>
</ol>


<p>
An empty DList is represented by having the sentinel's prev and next fields
point to itself.
</p>
<p>
Here's an example of a method that removes the last item from a DList.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">removeBack</span>() {
  <span style="color: #8ac6f2; font-weight: bold;">if</span> (head.prev != head) {        <span style="color: #99968b;">// </span><span style="color: #99968b;">Do nothing if the DList is empty.</span>
    head.prev = head.prev.prev;   <span style="color: #99968b;">// </span><span style="color: #99968b;">Sentinel now points to second-last item.</span>
    head.prev.next = head;        <span style="color: #99968b;">// </span><span style="color: #99968b;">Second-last item now points to sentinel.</span>
    size--;
  }
}
</pre>


<p>
In Lab 4 and Homework 4, you'll implement more methods for this DList class.
</p></div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Lecture 9</h2>
<div class="outline-text-2" id="text-8">

<p>Today's reading:  Sierra &amp; Bates pp. 77, 235-239, 258-265, 663.
</p>
</div>

<div id="outline-container-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> THE STACK AND THE HEAP</h3>
<div class="outline-text-3" id="text-8-1">

<p>Java stores stuff in two separate pools of memory:  the stack and the heap.
</p>
<p>
The <span style="text-decoration:underline;">heap</span> stores all objects, including all arrays, and all class variables
(i.e. those declared "static").
</p>
<p>
The <span style="text-decoration:underline;">stack</span> stores all local variables, including all parameters.
</p>
<p>
When a method is called, the Java Virtual Machine creates a <span style="text-decoration:underline;">stack frame</span> (also
known as an <span style="text-decoration:underline;">activation record</span>) that stores the parameters and local variables
for that method.  One method can call another, which can call another, and so
on, so the JVM maintains an internal <span style="text-decoration:underline;">stack</span> of stack frames, with "main" at
the bottom, and the most recent method call on top.
</p>
<p>
Here's a snapshot of the stack while Java is executing the SList.insertEnd
method.  The stack frames are on the left.  Everything on the right half of the
page is in the heap.  Read the stack from bottom to top, because that's the
order in which the stack frames were created.
</p>

<p>
<img src="ditaa-images/TEMP_1_79b96362c6f5a001d95e9b6c17990b88bda4ba98.png"  alt="ditaa-images/TEMP_1_79b96362c6f5a001d95e9b6c17990b88bda4ba98.png" />
</p>

<p>
The method that is currently executing (at any point in time) is the one whose
stack frame is on top.  All the other stack frames represent methods waiting
for the methods above them to return before they can continue executing.
</p>
<p>
When a method finishes executing, its stack frame is erased from the top of the
stack, and its local variables are erased forever.
</p>
<p>
The java.lang library has a method "Thread.dumpStack" that prints a list of the
methods on the stack (but it doesn't print their local variables).  This method
can be convenient for debugging&ndash;for instance, when you're trying to figure out
which method called another method with illegal parameters.
</p>
</div>

</div>

<div id="outline-container-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> Parameter Passing</h3>
<div class="outline-text-3" id="text-8-2">

<p>As in Scheme, Java passes all parameters <span style="text-decoration:underline;">by<sub>value</sub></span>.  This means that the
method has <span style="text-decoration:underline;">copies</span> of the actual parameters, and cannot change the originals.
The copies reside in the method's stack frame for the method.  The method can
change these copies, but the original values that were copied are not changed.
</p>
<p>
In this example, the method doNothing sets its parameter to 2, but it has no
effect on the value of the calling method's variable a:
</p>



<pre class="src src-text">method:                            | STACK (just before the method returns)
                                   |
  static void doNothing(int x) {   |      -----
    x = 2;                         |    x | 2 |
  }                                |      -----     stack frame for doNothing
                                   |-----------------------------------------
method call:                       |
                                   |      -----
  int a = 1;                       |    a | 1 |
  doNothing(a);                    |      -----     stack frame for main
</pre>


<p>
When the method call returns, a is still 1.  The doNothing method, as its name
suggests, failed to change the value of a or do anything relevant at all.
</p>
<p>
However, when a parameter is a reference to an object, the reference is copied,
but the object is not; the original object is shared.  A method can modify an
object that one of its parameters points to, and the change will be visible
everywhere.  Here's an example that shows how a method can make a change to an
object that is visible to the calling method:
</p>



<pre class="src src-text">method:                            | STACK              | HEAP
                                   |                set3|
class IntBox {                     |      -----         |
  public int i;                    |   ib | .-+----------------\
  static void set3(IntBox ib) {    |      -----         |      |
    ib.i = 3;                      |                    |      |
  }                                |--------------------|      v
                                   |      -----         |    ------
method call:                       |    b | .-+-------------&gt;|i |3|
                                   |      -----     main|    ------
  IntBox b = new IntBox();
  set3(b);
</pre>


<p>
For those of you who are familiar with programming languages that have "pass
by reference," the example above is as close as you can get in Java.  But it's
not "pass by reference."  Rather, it's passing a reference by value.
</p>


<p>
Here's an example of a common programming error, where a method tries and fails
to make a change that is visible to the calling method.  (Assume we've just
executed the example above, so b is set up.)
</p>


<pre class="src src-text">method:                            | STACK              | HEAP
                                   |             badSet4|
class IntBox {                     |      -----         |    ------
  static void badSet4(IntBox ib) { |   ib | .-+-------------&gt;|i |4|
    ib = new IntBox();             |      -----         |    ------
    ib.i = 4;                      |                    |
  }                                |--------------------|
                                   |      -----         |    ------
method call:                       |    b | .-+-------------&gt;|i |3|
                                   |      -----     main|    ------
  badSet4(b);
</pre>


</div>

</div>

<div id="outline-container-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> Binary search</h3>
<div class="outline-text-3" id="text-8-3">

<p>When a method calls itself recursively, the JVM's internal stack holds two or
more stack frames connected with that method.  Only the top one can be
accessed.
</p>
<p>
Here's a recursive method that searches a sorted array of ints for a particular
int.  Let i be an array of ints sorted from least to greatest&ndash;for instance,
{-3, -2, 0, 0, 1, 5, 5}.  We want to search the array for the value "findMe".
If we find "findMe", we return its array index; otherwise, we return FAILURE.
</p>
<p>
We could simply check every element of the array, but that would be slow.
A better strategy is to check the middle array element first.  If findMe is
lesser, we know it can only be in the left half of the array; if findMe is
greater, we know it can only be in the right half.  Hence, we've eliminated
half the possibilities with one comparison.  We still have half the array to
check, so we recursively check the middle element of that half, and so on,
cutting the possibilites in half each time.  Suppose we search for 1.
</p>

<p>
<img src="ditaa-images/TEMP_2_f03b371782eb33d7ed01575bcb731316bd4cc08d.png"  alt="ditaa-images/TEMP_2_f03b371782eb33d7ed01575bcb731316bd4cc08d.png" />
</p>

<p>
The recursion has two base cases.
</p><ol>
<li>If findMe equals the middle element, return its index; in the example
     above, we return index 4.
</li>
<li>If we try to search a subarray of length zero, the array does not contain
     "findMe", and we return FAILURE.
</li>
</ol>





<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #b0c4de;">final</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">FAILURE</span> = -<span style="color: #ffa07a;">1</span>;

<span style="color: #b0c4de;">private</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">bsearch</span>(<span style="color: #92a65e; font-weight: bold;">int</span>[] <span style="color: #cae682;">i</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">left</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">right</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">findMe</span>) {
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (left &gt; right) {
        <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #7fffd4;">FAILURE</span>;                   <span style="color: #99968b;">// </span><span style="color: #99968b;">Base case 2:  subarray of size zero.</span>
    }
    <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">mid</span> = (left + right) / <span style="color: #ffa07a;">2</span>;            <span style="color: #99968b;">// </span><span style="color: #99968b;">Halfway between left and right.</span>
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (findMe == i[mid]) {
        <span style="color: #8ac6f2; font-weight: bold;">return</span> mid;                                     <span style="color: #99968b;">// </span><span style="color: #99968b;">Base case 1:  success!</span>
    } <span style="color: #8ac6f2; font-weight: bold;">else</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> (findMe &lt; i[mid]) {
        <span style="color: #8ac6f2; font-weight: bold;">return</span> bsearch(i, left, mid - <span style="color: #ffa07a;">1</span>, findMe);            <span style="color: #99968b;">// </span><span style="color: #99968b;">Search left half.</span>
    } <span style="color: #8ac6f2; font-weight: bold;">else</span> {
        <span style="color: #8ac6f2; font-weight: bold;">return</span> bsearch(i, mid + <span style="color: #ffa07a;">1</span>, right, findMe);          <span style="color: #99968b;">// </span><span style="color: #99968b;">Search right half.</span>
    }
}

<span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">bsearch</span>(<span style="color: #92a65e; font-weight: bold;">int</span>[] <span style="color: #cae682;">i</span>, <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">findMe</span>) {
    <span style="color: #8ac6f2; font-weight: bold;">return</span> bsearch(i, <span style="color: #ffa07a;">0</span>, i.length - <span style="color: #ffa07a;">1</span>, findMe);
}
</pre>


<p>
How long does binary search take?  Suppose the array has n elements.  In one
call to bsearch, we eliminate at least half the elements from consideration.
Hence, it takes log<sub>2</sub> n (the base 2 logarithm of n) bsearch calls to pare down
the possibilities to one.  Binary search takes time proportional to log<sub>2</sub> n.
If you're not comfortable with logarithms, please review Goodrich &amp; Tamassia
Sections 4.1.2 &amp; 4.1.7.
</p>

<p>
<img src="ditaa-images/TEMP_3_8a3ff1957e48efafbe2b593085f36b159ead98a7.png"  alt="ditaa-images/TEMP_3_8a3ff1957e48efafbe2b593085f36b159ead98a7.png" />
</p>

<p>
The stack frames appear at right in the figure above.  There are three
different local variables named "left" on the stack, three named "right", three
named "mid", four named "i", and four named "findMe".  While the current
invocation of bsearch() is executing, only the topmost copy of "left" is in
scope, and likewise for "right" and "mid".  The other copies are hidden and
cannot be accessed or changed until the current invocation of bsearch()
terminates.
</p>
<p>
Most operating systems give a program enough stack space for a few thousand
stack frames.  If you use a recursive procedure to walk through a million-node
list, Java will try to create a million stack frames, and the stack will
run out of space.  The result is a run-time error.  You should use iteration
instead of recursion when the recursion will be very deep.
</p>
<p>
However, our recursive binary search method does not have this problem.  Most
modern microprocessors cannot address more than 2<sup>64</sup> bytes of memory.  Even if
an array of bytes takes this much space, we will only have to cut the array in
half 64 times to run a binary search.  There's room on the stack for 64 stack
frames, with plenty to spare.  In general, recursion to a depth of roughly
log n (where n is the number of items in a data structure) is safe, whereas
recursion to a depth of roughly n is not.
</p>
<p>
Unfortunately, binary search can't be used on linked lists.  Think about why.
</p>
</div>

</div>

<div id="outline-container-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> Scope and Recursion</h3>
<div class="outline-text-3" id="text-8-4">

<p>The <span style="text-decoration:underline;">scope</span> of a variable is the portion of the program that can access the
variable.  Here are some of Java's scoping rules.
</p>
<ul>
<li>Local variables and parameters are in scope only inside the method that
  declares them, and only for the topmost stack frame.  Furthermore, a local
  variable is in scope only from the variable declaration down to the innermost
  closing brace that encloses it.  A local variable declared in the
  initialization part of a "for" loop is in scope only in the loop body.
</li>
<li>Class variables (static fields) are in scope everywhere in the class, except
  when shadowed by a local variable or parameter of the same name.
</li>
<li>Fully qualified class variables ("System.out", rather than "out") are in
  scope everywhere in the class, and cannot be shadowed.  If they're public,
  they're in scope in <span style="text-decoration:underline;">all</span> classes.
</li>
<li>Instance variables (non-static fields) are in scope in non-static methods of
  the class, except when shadowed.
</li>
<li>Fully qualified instance variables ("amanda.name", "this.i") are in scope
  everywhere in the class, and cannot be shadowed.  If they're public, they're
  in scope in all classes.
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Lecture 10</h2>
<div class="outline-text-2" id="text-9">

<p>Today's reading:  All of Chapter 7, plus pp. 28-33, 250-257.
</p>
</div>

<div id="outline-container-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> INHERITANCE</h3>
<div class="outline-text-3" id="text-9-1">

<p>In Lab 3, you modified several methods in the SList class so that a "tail"
reference could keep track of the end of the list, thereby speeding up the
insertEnd() method.
</p>
<p>
We could have accomplished the same result without modifying SList&ndash;by creating
a new class that inherits all the properties of SList, and then changing only
the methods that need to change.  Let's create a new class called TailList that
inherits the fields and methods of the original SList class.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">TailList</span> <span style="color: #8ac6f2; font-weight: bold;">extends</span> <span style="color: #92a65e; font-weight: bold;">SList</span> {
  <span style="color: #99968b;">// </span><span style="color: #99968b;">The "head" and "size" fields are inherited from SList.</span>
  <span style="color: #b0c4de;">private</span> <span style="color: #92a65e; font-weight: bold;">SListNode</span> <span style="color: #cae682;">tail</span>;
</pre>


<p>
This code declares a TailList class that behaves just like the SList class, but
has an additional field "tail" not present in the SList class.  TailList is
said to be a <span style="text-decoration:underline;">subclass</span> of SList, and SList is the <span style="text-decoration:underline;">superclass</span> of TailList.
A TailList has three fields:  head, size, and tail.
</p>
<p>
A subclass can modify or augment a superclass in at least three ways:
</p><ol>
<li>It can declare new fields.
</li>
<li>It can declare new methods.
</li>
<li>It can override old methods with new implementations.
</li>
</ol>


<p>
We've already seen an example of the first.  Let's try out the third.  The
advantage of TailList is that it can perform the insertEnd() method much more
quickly than a tail-less SList can.  So, let's write a new insertEnd() for
TailList, which will <span style="text-decoration:underline;">override</span> SList's old, slow insertEnd() method.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">insertEnd</span>(<span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">obj</span>) {
    <span style="color: #99968b;">// </span><span style="color: #99968b;">Your solution to Lab 3 goes here.</span>
}
</pre>


<p>
The isEmpty(), length(), nth(), and toString() methods of SList do not need any
changes on account of the tail reference.  These methods are inherited from
SList, and there's no need to rewrite them.
</p>
</div>

</div>

<div id="outline-container-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> Inheritance and Constructors</h3>
<div class="outline-text-3" id="text-9-2">

<p>What happens when we construct a TailList?  Java executes a TailList
constructor, as you would expect, but <span style="text-decoration:underline;">first</span> it executes the code in the
SList() constructor.  The TailList constructor should initialize fields unique
to TailList.  It can also modify the work done by SList() if appropriate.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">TailList</span>() {
  <span style="color: #99968b;">// </span><span style="color: #99968b;">SList() constructor called automatically; sets size = 0, head = null</span>
  tail = <span style="color: #7fffd4;">null</span>;
}
</pre>


<p>
The zero-parameter SList() constructor is always called by default, regardless
of the parameters passed to the TailList constructor.  To change this default
behavior, the TailList constructor can explicitly call any constructor for its
superclass by using the "super" keyword.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">TailList</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">x</span>) {
    <span style="color: #8ac6f2; font-weight: bold;">super</span>(x);
    tail = <span style="color: #7fffd4;">null</span>;
}
</pre>


<p>
The call to "super()" must be the first statement in the constructor.  If a
constructor has no explicit call to "super", and its (nearest) superclass has
no zero-parameter constructor, a compile-time error occurs.  There is no way to
tell Java not to call a superclass constructor.  You have only the power to
choose which of the superclass constructors is called.
</p>
</div>

</div>

<div id="outline-container-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> Invoking Overridden Methods</h3>
<div class="outline-text-3" id="text-9-3">

<p>Sometimes you want to override a method, yet still be able to call the method
implemented in the superclass.  The following example shows how to do this.
Below, we want to reuse the code in SList.insertFront, but we also need to
adjust the tail reference.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">insertFront</span>(<span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">obj</span>) {
    <span style="color: #8ac6f2; font-weight: bold;">super</span>.insertFront(obj);             <span style="color: #99968b;">// </span><span style="color: #99968b;">Insert at the front of the list.</span>
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (size == <span style="color: #ffa07a;">1</span>) {                    <span style="color: #99968b;">// </span><span style="color: #99968b;">If necessary,</span>
        tail = head;                    <span style="color: #99968b;">//   </span><span style="color: #99968b;">adjust the tail reference.</span>
    }
}
}
</pre>


<p>
Unlike superclass constructor invocations, ordinary superclass method
invocations need not be the first statement in a method.
</p>
</div>

</div>

<div id="outline-container-9-4" class="outline-3">
<h3 id="sec-9-4"><span class="section-number-3">9.4</span> The "protected" Keyword</h3>
<div class="outline-text-3" id="text-9-4">

<p>I lied when I said that we don't need to modify SList.  One change is
necessary.  The "head" and "size" fields in SList must be declared "protected",
not "private".
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">SList</span> {
  <span style="color: #b0c4de;">protected</span> <span style="color: #92a65e; font-weight: bold;">SListNode</span> <span style="color: #cae682;">head</span>;
  <span style="color: #b0c4de;">protected</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">size</span>;

  [Method definitions.]
}
</pre>


<p>
"protected" is a level of protection somewhere between "public" and "private".
A "protected" field is visible to the declaring class and all its subclasses,
but not to other classes.  "private" fields aren't even visible to the
subclasses.
</p>
<p>
If "head" and "size" are declared private, the method TailList.insertFront
can't access them and won't compile.  If they're declared protected,
insertFront can access them because TailList is a subclass of SList.
</p>
<p>
When you write an ADT, if you think somebody might someday want to write a
subclass of it, declare its vulnerable fields "protected", unless you have a
reason for not wanting subclasses to see them.  Helper methods often should be
declared "protected" as well.
</p>
</div>

</div>

<div id="outline-container-9-5" class="outline-3">
<h3 id="sec-9-5"><span class="section-number-3">9.5</span> Class Hierarchies</h3>
<div class="outline-text-3" id="text-9-5">

<p>Subclasses can have subclasses.  Subclassing is transitive:  if Proletariat is
a subclass of Worker, and Student is a subclass of Proletariat, then Student is
a subclass of Worker.  Furthermore, <span style="text-decoration:underline;">every</span> class is a subclass of the Object
class (including Java's built-in classes like String and BufferedReader.)
Object is at the top of every class hierarchy.
</p>

<p>
<img src="ditaa-images/img1_49e01f5a87853670b8a5a9dedec256441e611d22.png"  alt="ditaa-images/img1_49e01f5a87853670b8a5a9dedec256441e611d22.png" />
</p>

<p>
That's why the "item" field in each listnode is of type Object:  it can
reference any object of any class.  (It can't reference a primitive type,
though.)
</p>
</div>

</div>

<div id="outline-container-9-6" class="outline-3">
<h3 id="sec-9-6"><span class="section-number-3">9.6</span> Dynamic Method Lookup</h3>
<div class="outline-text-3" id="text-9-6">

<p>Here's where inheritance gets interesting.  Any TailList can masquerade as an
SList.  An object of class TailList can be assigned to a variable of type
SList&ndash;but the reverse is not true.  Every TailList is an SList, but not every
SList is a TailList.  It merits repeating:
</p>
<p>
 !!!  <span style="text-decoration:underline;">Every TailList *IS* an SList</span>. !!!   For example:
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">SList</span> <span style="color: #cae682;">s</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">TailList</span>();         <span style="color: #99968b;">// </span><span style="color: #99968b;">Groovy.</span>
<span style="color: #92a65e; font-weight: bold;">TailList</span> <span style="color: #cae682;">t</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">SList</span>();         <span style="color: #99968b;">// </span><span style="color: #99968b;">COMPILE-TIME ERROR.</span>
</pre>


<p>
Memorize the following two definitions.
</p><ul>
<li><span style="text-decoration:underline;">Static type</span>:  The type of a variable.
</li>
<li><span style="text-decoration:underline;">Dynamic type</span>:  The class of the object the variable references.
</li>
</ul>


<p>
In the code above, the static type of s is SList, and the dynamic type of s is
TailList.  Henceforth, I will often just say "type" for static type and "class"
for dynamic type.
</p>
<p>
When we invoke an overridden method, Java calls the method for the object's
<span style="text-decoration:underline;">dynamic</span> type, regardless of the variable's static type.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">SList</span> <span style="color: #cae682;">s</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">TailList</span>();
s.insertEnd(obj);                 <span style="color: #99968b;">// </span><span style="color: #99968b;">Calls TailList.insertEnd()</span>
s = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">SList</span>();
s.insertEnd(obj);                 <span style="color: #99968b;">// </span><span style="color: #99968b;">Calls SList.insertEnd()</span>
</pre>


<p>
This is called <span style="text-decoration:underline;">dynamic method lookup</span>, because Java automatically looks up the
right method for a given object at run-time.  Why is it interesting?
</p>
<p>
<span style="text-decoration:underline;">WHY DYNAMIC METHOD LOOKUP MATTERS</span>    (Worth reading and rereading)
</p>
<p>                                                                           
Suppose you have a method (in any class) that sorts an SList using only    
SList method calls (but doesn't construct any SLists).  Your method now    
sorts TailLists too, with no changes.                                      
</p>
<p>                                                                           
Suppose you've written a class&ndash;let's call it RunLengthEncoding&ndash;that uses 
SLists extensively.  By changing the constructors so that they create      
TailLists instead of SLists, your class immediately realizes the           
performance improvement that TailLists provide&ndash;without changing anything  
else in the RunLengthEncoding class.                                       
</p>
</div>

</div>

<div id="outline-container-9-7" class="outline-3">
<h3 id="sec-9-7"><span class="section-number-3">9.7</span> Subtleties of Inheritance</h3>
<div class="outline-text-3" id="text-9-7">

<p>(1)  Suppose we write a new method in the TailList class called eatTail().  We
can't call eatTail on an SList.  We can't even call eatTail on a variable of
type SList that references a TailList.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">TailList</span> <span style="color: #cae682;">t</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">TailList</span>();
t.eatTail();                      <span style="color: #99968b;">// </span><span style="color: #99968b;">Groovy.</span>
<span style="color: #92a65e; font-weight: bold;">SList</span> <span style="color: #cae682;">s</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">TailList</span>();         <span style="color: #99968b;">// </span><span style="color: #99968b;">Groovy--every TailList is an SList.</span>
s.eatTail();                      <span style="color: #99968b;">// </span><span style="color: #99968b;">COMPILE-TIME ERROR.</span>
</pre>


<p>
Why?  Because not every object of class SList has an "eatTail()" method, so
Java can't use dynamic method lookup on the variable s.
</p>
<p>
But if we define eatTail() in SList instead, the statements above compile and
run without errors, even if no eatTail() method is defined in class TailList.
(TailList inherits eatTail() from SList.)
</p>
<p>
(2)  I pointed out earlier that you can't assign an SList object to a TailList
variable.  The rules are more complicated when you assign one variable to
another.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">SList</span> <span style="color: #cae682;">s</span>;
<span style="color: #92a65e; font-weight: bold;">TailList</span> <span style="color: #cae682;">t</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">TailList</span>();
s = t;                            <span style="color: #99968b;">// </span><span style="color: #99968b;">Groovy.</span>
t = s;                            <span style="color: #99968b;">// </span><span style="color: #99968b;">COMPILE-TIME ERROR.</span>
t = (<span style="color: #92a65e; font-weight: bold;">TailList</span>) s;                 <span style="color: #99968b;">// </span><span style="color: #99968b;">Groovy.</span>
s = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">SList</span>();
t = (<span style="color: #92a65e; font-weight: bold;">TailList</span>) s;                 <span style="color: #99968b;">// </span><span style="color: #99968b;">RUN-TIME ERROR:  ClassCastException.</span>
</pre>


<p>
Why does the compiler reject "t = s", but accept "t = (TailList) s"?  It
refuses "t = s" because not every SList is a TailList, and it wants you to
confirm that you're not making a thoughtless mistake.  The cast in the latter
statement is your way of reassuring the compiler that you've designed the
program to make sure that the SList s will always be a TailList.
</p>
<p>
If you're wrong, Java will find out when you run the program, and will crash
with a "ClassCastException" error message.  The error occurs only at run-time
because Java cannot tell in advance what class of object s will reference.
</p>
<p>
Recall that SLists store items of type Object.  When they're recovered, they
usually have to be cast back to a more specific type before they can be used.
Suppose we have a list of Integers.  Recall that nth() returns type Object.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">x</span> = t.nth(<span style="color: #ffa07a;">1</span>).intValue();                <span style="color: #99968b;">// </span><span style="color: #99968b;">COMPILE-TIME ERROR.</span>
<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">y</span> = ( (<span style="color: #92a65e; font-weight: bold;">Integer</span>) t.nth(<span style="color: #ffa07a;">1</span>) ).intValue();  <span style="color: #99968b;">// </span><span style="color: #99968b;">Groovy.</span>
</pre>


<p>
Some methods are defined on every Object, though.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">z</span> = t.nth(<span style="color: #ffa07a;">1</span>).toString();             <span style="color: #99968b;">// </span><span style="color: #99968b;">Groovy.</span>
</pre>


<p>
(3)  Java has an "instanceof" operator that tells you whether an object is of
a specific class.  WARNING:  The "o" in "instanceof" is not capitalized.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">if</span> (s <span style="color: #8ac6f2; font-weight: bold;">instanceof</span> <span style="color: #92a65e; font-weight: bold;">TailList</span>) {
  t = (<span style="color: #92a65e; font-weight: bold;">TailList</span>) s;
}
</pre>


<p>
This instanceof operation will return false if s is null or doesn't reference
a TailList.  It returns true if s references a TailList object&ndash;even if it's
a subclass of TailList.
</p></div>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Lecture 11</h2>
<div class="outline-text-2" id="text-10">

<p>Today's reading:  Sierra &amp; Bates, pp. 95-109, 662.
</p>
</div>

<div id="outline-container-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> equals()</h3>
<div class="outline-text-3" id="text-10-1">

<p>Every class has an equals() method.  If you don't define one explictly, you
inherit Object.equals(), for which "r1.equals(r2)" returns the same boolean
value as "r1 == r2", where r1 and r2 are references.  However, many classes
override equals() to compare the <span style="text-decoration:underline;">content</span> of two objects.
</p>
<p>
Integer (in the java.lang library) is such a class; it stores one private int.
Two distinct Integer objects are equals() if they contain the same int.
In the following example, "i1 == i2" is false, but "i1.equals(i2)" is true.
"i2 == i3" and "i2.equals(i3)" are both true.
</p>

<p>
<img src="ditaa-images/TEMP_1_75da5d56f2c380500effcf07b8cc9cd780b8e978.png"  alt="ditaa-images/TEMP_1_75da5d56f2c380500effcf07b8cc9cd780b8e978.png" />
</p>

<p>
IMPORTANT:  r1.equals(r2) throws a run-time exception if r1 is null.
</p>
<p>
There are at least four different degrees of equality.
</p><ol>
<li>Reference equality, ==.  (The default inherited from the Object class.)
</li>
<li>Shallow structural equality:  two objects are "equals" if all their fields
     are ==.  For example, two SLists whose "size" fields are equal and whose
     "head" fields point to the same SListNode.
</li>
<li>Deep structural equality:  two objects are "equals" if all their fields
     are "equals".  For example, two SLists that represent the same sequence of
     items (though the SListNodes may be different).
</li>
<li>Logical equality.  Two examples:
      a.  Two "Set" objects are "equals" if they contain the same elements,
          even if the underlying lists store the elements in different orders.
      b.  The Fractions 1/3 and 2/6 are "equals", even though their numerators
          and denominators are all different.
</li>
</ol>


<p>
The equals() method for a particular class may test any of these four levels of
equality, depending on what seems appropriate.  Let's write an equals() method
for SLists that tests for deep structural equality.  The following method
returns true only if the two lists represent identical sequences of items.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">SList</span> {
    <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">boolean</span> <span style="color: #cae682;">equals</span>(<span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">other</span>) {
        <span style="color: #8ac6f2; font-weight: bold;">if</span> (!(other <span style="color: #8ac6f2; font-weight: bold;">instanceof</span> <span style="color: #92a65e; font-weight: bold;">SList</span>)) {           <span style="color: #99968b;">// </span><span style="color: #99968b;">Reject non-SLists.</span>
            <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #7fffd4;">false</span>;
        }

        <span style="color: #92a65e; font-weight: bold;">SList</span> <span style="color: #cae682;">o</span> = (<span style="color: #92a65e; font-weight: bold;">SList</span>) other;
        <span style="color: #8ac6f2; font-weight: bold;">if</span> (size != o.size) {
            <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #7fffd4;">false</span>;
        }

        <span style="color: #92a65e; font-weight: bold;">SListNode</span> <span style="color: #cae682;">n1</span> = head;
        <span style="color: #92a65e; font-weight: bold;">SListNode</span> <span style="color: #cae682;">n2</span> = o.head;
        <span style="color: #8ac6f2; font-weight: bold;">while</span> (n1 != <span style="color: #7fffd4;">null</span>) {
            <span style="color: #8ac6f2; font-weight: bold;">if</span> (!n1.item.equals(n2.item)) {          <span style="color: #99968b;">// </span><span style="color: #99968b;">Deep equality of the items.</span>
                <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #7fffd4;">false</span>;
            }
            n1 = n1.next;
            n2 = n2.next;
        }
        <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #7fffd4;">true</span>;
    }
}
</pre>


<p>
Note that this implementation may fail if the SList invariants have been
corrupted.  (A wrong "size" field or a loop in an SList can make it fail.)
</p>
<p>
IMPORTANT:  Overriding DOESN'T WORK if we change the signature of the original
method, even just to change a parameter to a subclass.  In the Object class,
the signature is equals(Object), so in the code above, we must declare "other"
to be an Object too.  If we declare "other" to be an SList, the equals() method
will compile but it will NOT override.  That means the code
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">s</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">SList</span>();
s.equals(s);
</pre>


<p>
will call Object.equals(), not SList.equals().  Dynamic method lookup won't
care that s is an SList, because the equals() method above is not eligible to
override Object.equals().
</p>
<p>
Therefore, if you want to override a method, make sure the signature is EXACTLY
the same.
</p>
</div>

</div>

<div id="outline-container-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> "for each" LOOPS</h3>
<div class="outline-text-3" id="text-10-2">

<p>Java has a "for each" loop for iterating through the elements of an array.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">int</span>[] <span style="color: #cae682;">array</span> = {<span style="color: #ffa07a;">7</span>, <span style="color: #ffa07a;">12</span>, <span style="color: #ffa07a;">3</span>, <span style="color: #ffa07a;">8</span>, <span style="color: #ffa07a;">4</span>, <span style="color: #ffa07a;">9</span>};

<span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span> : array) {
  System.out.print(i + <span style="color: #95e454;">" "</span>);
}
</pre>


<p>
Note that i is <span style="text-decoration:underline;">not</span> iterating from 0 to 5; it's taking on the value of each
array element in turn.  You can iterate over arrays of any type this way.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">concat</span> = <span style="color: #95e454;">""</span>;
<span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #cae682;">s</span> : stringArray) {
  concat = concat + s;
}
</pre>


<p>
For some reason, the type declaration <span style="text-decoration:underline;">must</span> be in the "for" statement.  The
compiler barfs if you try
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">i</span>;
<span style="color: #8ac6f2; font-weight: bold;">for</span> (i : array) { ... }
</pre>


</div>

</div>

<div id="outline-container-10-3" class="outline-3">
<h3 id="sec-10-3"><span class="section-number-3">10.3</span> TESTING</h3>
<div class="outline-text-3" id="text-10-3">

<p>Complex software, like Project 1, is easier to debug if you write lots of test
code.  We'll consider three types of testing:
</p>
<ol>
<li>Modular testing:  testing each method and each class separately.
</li>
<li>Integration testing:  testing a set of methods/classes together.
</li>
<li>Result verification:  testing results for correctness, and testing data
       structures to ensure they still satisfy their invariants.
</li>
</ol>



</div>

<div id="outline-container-10-3-1" class="outline-4">
<h4 id="sec-10-3-1"><span class="section-number-4">10.3.1</span> Modular Testing</h4>
<div class="outline-text-4" id="text-10-3-1">

<p>When you write a program and it fails, it can be quite difficult to determine
which part of the code is responsible.  Even experienced programmers often
guess wrong.  It's wise to test every method you write individually.
</p>
<p>
There are two types of test code for modular testing:  test drivers and stubs.
</p>
<p>
(a)  Test drivers are methods that call the code being tested, then check the
results.  In Lab 3 and Homework 3, you've seen test drivers in the SList class
that check that your code is doing the right thing.
</p>
<p>
Both public and private methods should be tested.  Hence, a test driver usually
needs to be inside the class it tests.  In a class intended for use by other
classes, the obvious place to put a test driver is in the main() method, as we
did in Lab 3 and Homework 3.  However, if a class is the entry point for the
program, you can't put your test driver in main().  Instead, put it in a method
with a name like testDriver(), and then write <span style="text-decoration:underline;">another</span> class whose main()
method calls your test driver.
</p>
<p>
(b)  Stubs are small bits of code that are <span style="text-decoration:underline;">called</span> by the code being tested.
They are often quite short.  They serve three purposes.
</p>
<p>
(i)  If you write a method that calls other methods that haven't yet been
     implemented, you can write simple stubs that fake the missing methods.
(ii) Suppose you are having difficulty determining whether a bug lies in
     a calling method, or a method it calls.  You can temporarily replace the
     callee with a stub that returns controlled results to the caller, so you
     can see if the caller is responsible for the problem.
(iii)Stubs allow you to create repeatable test cases that might not arise often
     in practice.  For instance, suppose a subroutine fetches and returns input
     from an airline database, and your code calls this subroutine.  You might
     want to test whether your code operates correctly when ten airplanes
     depart at the same time.  Such an event might be rare in practice, but you
     can replace the database access subroutine with a stub that feeds fake
     data to your code.  There are two advantages:
</p>
<ul>
<li>Stubs can produce test data that the real code rarely or never produces.
</li>
<li>Stubs produce <span style="text-decoration:underline;">repeatable</span> test data, so that bugs can be reproduced.
</li>
</ul>


</div>

</div>

<div id="outline-container-10-3-2" class="outline-4">
<h4 id="sec-10-3-2"><span class="section-number-4">10.3.2</span> Integration Testing</h4>
<div class="outline-text-4" id="text-10-3-2">

<p>Integration testing is testing all the components together (preferably <span style="text-decoration:underline;">after</span>
you have tested them in isolation).  Sometimes bugs arise during integration
because your test cases weren't thorough enough.  Other times, they arise
because of misunderstandings about how the components are supposed to interact
with each other.  Integration testing is harder than modular testing, because
it's harder to determine where a bug is, or to identify your mistaken
assumptions about how the components interact.
</p>
<p>
The most important task in avoiding these bugs is to define your interfaces
well and unambiguously.  There should be no ambiguity in the descriptions of
the behavior of your methods, especially in unusual cases.  We'll talk a lot
more about this in later lectures.
</p>
<p>
The best advice I can give on integration testing:  learn to use a debugger.
</p>
</div>

</div>

<div id="outline-container-10-3-3" class="outline-4">
<h4 id="sec-10-3-3"><span class="section-number-4">10.3.3</span> Result Verification</h4>
<div class="outline-text-4" id="text-10-3-3">

<p>A result verifier is a method that checks the results of other methods.  There
are at least two types of result verifiers you can write.
</p>
<p>
(a)  Data structure integrity checkers.  A method can inspect a data structure
     (like a list) and verify that all the invariants are satisfied.  For
     Project 1, we are asking you to write a simple checker named "check()"
     that verifies the integrity of your run-length encodings.
(b)  Algorithm result checkers.  A method can inspect the output of another
     method for correctness.  For example, if a method is supposed to sort an
     array of numbers, a result checker can walk through the output and check
     that each item really is less than or equal to its successor.
</p>
<p>
An <span style="text-decoration:underline;">assertion</span> is a piece of code that tests an invariant or a result.
Java offers an "assert" keyword that tests whether an assertion evaluates to
"true".  If the assertion comes up "false", Java terminates the program with an
"AssertionError" error message, a stack trace, and an optional message of your
own choosing.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">assert</span> <span style="color: #cae682;">x</span> == <span style="color: #ffa07a;">3</span>;
<span style="color: #8ac6f2; font-weight: bold;">assert</span> list.<span style="color: #cae682;">size</span> == list.countLength() : <span style="color: #95e454;">"wrong SList size:  "</span> + list.size;
</pre>


<p>
At the end of each method that changes a data structure, add assertions
(possibly a call to an integrity checker).  At the end of each method that
computes a result, add an assertion that calls a result checker.
</p>
<p>
Assertions are convenient because you can turn them on or off.  To turn them on
when you're testing your code, run your code with "java -ea" (for "enable
assertions").  To turn them off for greater speed, run with "java -da" (for
"disable assertions").  The default (if you specify no switch) is -da.
WARNING:  when assertions are turned off, the method "list.countLength()" above
is never called.  Good for speed, but countLength() must not perform a task
that is necessary for your program's correctness.
</p>
</div>

</div>

<div id="outline-container-10-3-4" class="outline-4">
<h4 id="sec-10-3-4"><span class="section-number-4">10.3.4</span> Regression Testing</h4>
<div class="outline-text-4" id="text-10-3-4">

<p>A <span style="text-decoration:underline;">regression test</span> is a test suite can be re-run whenever changes are made to
the code.  Nearly every software company has reams of regression tests for each
product.  They run them again every time they fix a bug or add a feature.
</p>
<p>
Some principles of regression testing:
</p>
<p>
 a.  All-paths testing:  your test cases should try to test every path through
     the code.  Test every method.  For every "if" statement, you should try to
     write a test case for each of the two paths.
 b.  "Boundary cases" should be tested, as well as non-boundary cases.  For
     instance, if you write a binary search method, test it on arrays of
     lengths zero and one, as well as longer lengths.  Test the cases where the
     item sought is the first element, the last element, in the middle, not
     present.  For every loop in the code, try to test the cases where it
     iterates zero or one times, as well as the case where it iterates several
     times.  Test the branch "if (x &gt;= 1)" for x equal to 0, 1, and 2.
 c.  Generally, methods can be divided into two types:  extenders, which
     construct or change an object; and observers, which return information
     about an object.  (Some methods do both, but you should always think hard
     about whether that's good design.)  Ideally, your test cases should test
     every combination of extender and observer.
</p>
<p>
In real-world software development, the size of the test code is often larger
than the size of the code being tested.
</p></div>
</div>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Lecture 12</h2>
<div class="outline-text-2" id="text-11">

<p>Today's reading:  Sierra &amp; Bates, Chapter 8.
</p>
</div>

<div id="outline-container-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> ABSTRACT CLASSES</h3>
<div class="outline-text-3" id="text-11-1">

<p>An abstract class is a class whose sole purpose is to be extended.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">abstract</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">List</span> {
  <span style="color: #b0c4de;">protected</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">size</span>;

  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">length</span>() {
    <span style="color: #8ac6f2; font-weight: bold;">return</span> size;
  }

  <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">abstract</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">insertFront</span>(<span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">item</span>);
}
</pre>


<p>
Abstract classes don't allow you to create objects directly.  You can declare a
variable of type List, but you can't create a List object.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">List</span> <span style="color: #cae682;">myList</span>;                 <span style="color: #99968b;">// </span><span style="color: #99968b;">Right on.</span>
myList = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">List</span>();         <span style="color: #99968b;">// </span><span style="color: #99968b;">COMPILE-TIME ERROR.</span>
</pre>


<p>
However, abstract classes can be extended in the same way as ordinary classes,
and the subclasses are usually not abstract.  (They can be, but usually they're
normal subclasses with complete implementations.)
</p>
<p>
The abstract List class above includes an abstract method, insertFront.  An
abstract method lacks an implementation.  One purpose of an abstract method is
to guarantee that every non-abstract subclass will implement the method.
Specifically, every non-abstract subclass of List must have an implementation
for the insertFront method.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">SList</span> <span style="color: #8ac6f2; font-weight: bold;">extends</span> <span style="color: #92a65e; font-weight: bold;">List</span> {
  <span style="color: #99968b;">// </span><span style="color: #99968b;">inherits the "size" field.</span>
  <span style="color: #b0c4de;">protected</span> <span style="color: #92a65e; font-weight: bold;">SListNode</span> <span style="color: #cae682;">head</span>;

  <span style="color: #99968b;">// </span><span style="color: #99968b;">inherits the "length" method.</span>

  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">insertFront</span>(<span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">item</span>) {
    head = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">SListNode</span>(item, head);
    size++;
  }  
}
</pre>


<p>
If you leave out the implementation of insertFront in SList, the Java compiler
will complain that you must provide one.  A non-abstract class may never
contain an abstract method, nor inherit one without providing an
implementation.
</p>
<p>
Because SList is not abstract, we can create SList objects; and because SLists
are Lists, we can assign an SList to a List variable.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">List</span> <span style="color: #cae682;">myList</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">SList</span>();   <span style="color: #99968b;">// </span><span style="color: #99968b;">Right on.</span>
myList.insertFront(obj);     <span style="color: #99968b;">// </span><span style="color: #99968b;">Right on.</span>
</pre>


<p>
What are abstract classes good for?  It's all about the interface.
</p>

<hr/>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">An abstract class lets you define an interface</td></tr>
<tr><td class="left">- for multiple classes to share,</td></tr>
<tr><td class="left">- without defining any of them yet.</td></tr>
</tbody>
</table>


<hr/>

<p>
Let's consider the List class.  Although the List class is abstract, it is an
ADT&ndash;even without any implementation!&ndash; because it has an interface with public
method prototypes and well-defined behaviors.  We can implement an
algorithm&ndash;for example, a list sorter&ndash;based on the List interface, without
ever knowing how the lists will be implemented.  One list sorter can sort every
kind of List.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">listSort</span>(<span style="color: #92a65e; font-weight: bold;">List</span> <span style="color: #cae682;">l</span>) { ... }
</pre>


<p>
In another part of the universe, your project partners can build lots of
subclasses of List:  SList, DList, TailList, and so on.  They can also build
special-case List subclasses: for example, a TimedList that records the amount
of time spent doing List operations, and a TransactionList that logs all
changes made to the list on a disk so that all information can be recovered if
a power outage occurs.  A library catalogue application that uses DLists can
send them to your listSort algorithm to be sorted.  An airline flight database
that uses TransactionLists can send them to you for sorting, too, and you don't
have to change a line of sorting code.  You may have written your list sorter
years before TransactionLists were ever thought of.
</p>

<p>
The list sorter is built on the foundation of a list  
ADT, and the application is built on the foundation of
the list sorter.  However, it's the application, and  
not the list sorter, that gets to choose what kind of 
list is actually used, and thereby obtains special    
features like transaction logging.  This is a big     
advantage of object-oriented languages like Java.
</p>
<p>
<img src="ditaa-images/TEMP_2_07f8ba5ffaf13fb531100754106baba5dd99a57c.png"  alt="ditaa-images/TEMP_2_07f8ba5ffaf13fb531100754106baba5dd99a57c.png" />
</p>

</div>

</div>

<div id="outline-container-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> JAVA INTERFACES</h3>
<div class="outline-text-3" id="text-11-2">

<p>Java has an "interface" keyword which refers to something quite different than
the interfaces I defined in Lecture 8, even though the two interfaces are
related.  Henceforth, when I say "interfaces" I mean public fields, public
method prototypes, and the behaviors of public methods.  When I say "Java
interfaces" I mean Java's "interface" keyword.
</p>
<p>
A Java interface is just like an abstract class, except for two differences.
</p><ol>
<li>In Java, a class can inherit from only one class, even if the superclass
     is an abstract class.  However, a class can "implement" (inherit from) as
     many Java interfaces as you like.
</li>
<li>A Java interface cannot implement any methods, nor can it include any
     fields except "final static" constants.  It only contains method
     prototypes and constants.
</li>
</ol>





<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">interface</span> <span style="color: #92a65e; font-weight: bold;">Nukeable</span> {               <span style="color: #99968b;">// </span><span style="color: #99968b;">In Nukeable.java</span>
  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">nuke</span>();
}

<span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">interface</span> <span style="color: #92a65e; font-weight: bold;">Comparable</span> {             <span style="color: #99968b;">// </span><span style="color: #99968b;">In java.lang</span>
  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">compareTo</span>(<span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">o</span>);
}

<span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">SList</span> <span style="color: #8ac6f2; font-weight: bold;">extends</span> <span style="color: #92a65e; font-weight: bold;">List</span> <span style="color: #8ac6f2; font-weight: bold;">implements</span> <span style="color: #92a65e; font-weight: bold;">Nukeable</span>, <span style="color: #92a65e; font-weight: bold;">Comparable</span> {
  [Previous stuff here.]

  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> nuke() {
    head = <span style="color: #7fffd4;">null</span>;
    size = <span style="color: #ffa07a;">0</span>;
  }

  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">compareTo</span>(<span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">o</span>) {
    [Returns a number &lt; <span style="color: #ffa07a;">0</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> <span style="color: #8ac6f2; font-weight: bold;">this</span> &lt; o,
                        <span style="color: #ffa07a;">0</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> <span style="color: #8ac6f2; font-weight: bold;">this</span>.equals(o), 
                      &gt; <span style="color: #ffa07a;">0</span> <span style="color: #8ac6f2; font-weight: bold;">if</span> <span style="color: #8ac6f2; font-weight: bold;">this</span> &gt; o.]
  }
}
</pre>


<p>
Observe that the method prototypes in a Java interface may be declared without
the "abstract" keyword, because it would be redundant; a Java interface cannot
contain a method implementation.
</p>
<p>
The distinction between abstract classes and Java interfaces exists because of
technical reasons that you might begin to understand if you take CS 164
(Compilers).  Some languages, like C++, allow "multiple inheritance," so that a
subclass can inherit from several superclasses.  Java does not allow multiple
inheritance in its full generality, but it offers a sort of crippled form of
multiple inheritance:  a class can "implement" multiple Java interfaces.
</p>
<p>
Why does Java have this limitation?  Multiple inheritance introduces a lot of
problems in both the definition of a language and the efficient implementation
of a language.  For example, what should we do if a class inherits from two
different superclasses two different methods or fields with the same name?
Multiple inheritance is responsible for some of the scariest tricks and traps
of the C++ language, subtleties that cause much wailing and gnashing of teeth.
Java interfaces don't have these problems.
</p>
<p>
Because an SList is a Nukeable and a Comparable, we can assign it to variables
of these types.
</p>



<pre class="src src-java"><span style="color: #92a65e; font-weight: bold;">Nukeable</span> <span style="color: #cae682;">n</span> = <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">SList</span>();
<span style="color: #92a65e; font-weight: bold;">Comparable</span> <span style="color: #cae682;">c</span> = (<span style="color: #92a65e; font-weight: bold;">Comparable</span>) n;
</pre>


<p>
The cast is required because not every Nukeable is a Comparable.
</p>
<p>
"Comparable" is a standard interface in the Java library.  By having a class
implement Comparable, you immediately gain access to Java's sorting library.
For instance, the Arrays class in java.util includes a method that sorts arrays
of Comparable objects.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">static</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">sort</span>(<span style="color: #92a65e; font-weight: bold;">Object</span>[] <span style="color: #cae682;">a</span>)       <span style="color: #99968b;">// </span><span style="color: #99968b;">In java.util</span>
</pre>


<p>
The parameter's type is Object[], but a run-time error will occur if any item
stored in a is not a Comparable.
</p>
<p>
Interfaces can be extended with subinterfaces.  A subinterface can have
multiple superinterfaces, so we can group several interfaces into one.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">interface</span> <span style="color: #92a65e; font-weight: bold;">NukeAndCompare</span> <span style="color: #8ac6f2; font-weight: bold;">extends</span> <span style="color: #92a65e; font-weight: bold;">Nukeable</span>, <span style="color: #92a65e; font-weight: bold;">Comparable</span> { }
</pre>


<p>
We could also add more method prototypes and constants, but in this example
I don't.
</p></div>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> Lecture 13</h2>
<div class="outline-text-2" id="text-12">

<p>Today's reading:  Sierra &amp; Bates, pp. 154-160, 587-591, 667-668.
</p>
</div>

<div id="outline-container-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> JAVA PACKAGES</h3>
<div class="outline-text-3" id="text-12-1">

<p>In Java, a <span style="text-decoration:underline;">package</span> is a collection of classes and Java interfaces, and
possibly subpackages, that trust each other.  Packages have three benefits.
</p>
<ol>
<li>Packages can contain hidden classes that are used by the package but are
     not visible or accessible outside the package.
</li>
<li>Classes in packages can have fields and methods that are visible by all
     classes inside the package, but not outside.
</li>
<li>Different packages can have classes with the same name.  For example,
     java.awt.Frame and photo.Frame.
</li>
</ol>


<p>
Here are two examples of packages.
</p>
<ol>
<li>java.io is a package of I/O-related classes in the standard Java
     libraries.
</li>
<li>Homework 4 uses "list", a package containing the classes DList and
     DListNode.  You will be adding two additional classes to the list package.
</li>
</ol>


<p>
Package names are hierarchical.  java.awt.image.Model refers to the class Model
inside the package image inside the package awt inside the package java.
</p>

</div>

<div id="outline-container-12-1-1" class="outline-4">
<h4 id="sec-12-1-1"><span class="section-number-4">12.1.1</span> Using Packages</h4>
<div class="outline-text-4" id="text-12-1-1">

<p>You can address any class, field, or method with a fully-qualified name.
Here's an example of all three in one.
</p>



<pre class="src src-java"><span style="color: #e5786d;">java</span>.<span style="color: #e5786d;">lang</span>.System.out.println(<span style="color: #95e454;">"My fingers are tired."</span>);
</pre>


<p>
Java's "import" command saves us from the tedium of using fully-qualified names
all the time.
</p>



<pre class="src src-java"><span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #63b8ff;">java.io.</span><span style="color: #92a65e; font-weight: bold;">File</span>;  <span style="color: #99968b;">// </span><span style="color: #99968b;">Can now refer to File class, not just java.io.File.</span>
<span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #63b8ff;">java.io.*</span>;     <span style="color: #99968b;">// </span><span style="color: #99968b;">Can now refer to everything in java.io.</span>
</pre>


<p>
Every Java program implicitly imports java.lang.*, so you don't have to import
it explicitly to use System.out.println().  However, if you import packages
that contain multiple classes with the same name, you'll need to qualify their
names explicitly throughout your code.
</p>



<pre class="src src-java"><span style="color: #e5786d;">java</span>.<span style="color: #e5786d;">awt</span>.Frame.add(<span style="color: #e5786d;">photo</span>.Frame.canvas);
</pre>


<p>
Any package you create must appear in a directory of the same name.  For
example, the photo.Frame class bytecode appears in photo/Frame.class, and
x.y.z.Class appears in x/y/z/Class.class.  Where are the photo and x
directories?  They can appear in any of the directories on your "classpath".
You can specify a classpath on the command line, as when you type
</p>



<pre class="src src-java">javac -cp <span style="color: #95e454;">".:~jrs/classes:libraries.jar"</span> *.java
</pre>


<p>
This means that Java first looks in ".", the current directory, then looks in
~jrs/classes/, then finally in the <span style="text-decoration:underline;">Java archive</span> libraries.jar when it's
looking for the photo and x directories.  The classpath does not include the
location of the Java standard library packages (those beginning with java or
javax).  The Java compiler knows where to find them.
</p>
</div>

</div>

<div id="outline-container-12-1-2" class="outline-4">
<h4 id="sec-12-1-2"><span class="section-number-4">12.1.2</span> Building Packages</h4>
<div class="outline-text-4" id="text-12-1-2">

<p>The files that form a package are annotated with a "package" command, which
specifies the name of the package, which must match the name of the directory
in which the files appear.
</p>



<pre class="src src-java"><span style="color: #99968b;">/* </span><span style="color: #99968b;">list/SList.java */</span>                |  <span style="color: #99968b;">/* </span><span style="color: #99968b;">list/SListNode.java */</span>
                                     |
<span style="color: #8ac6f2; font-weight: bold;">package</span> <span style="color: #63b8ff;">list</span>;                        |  <span style="color: #8ac6f2; font-weight: bold;">package</span> <span style="color: #63b8ff;">list</span>;
                                     |
<span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> SList {                 |  <span style="color: #8ac6f2; font-weight: bold;">class</span> SListNode {
  <span style="color: #92a65e; font-weight: bold;">SListNode</span> <span style="color: #cae682;">head</span>;                    |    Object item;
  <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">size</span>;                          |    SListNode next;
}                                    |  }
</pre>


<p>
Here, the SListNode class and its fields are marked neither public, private,
nor protected.  Instead, they have "package" protection, which falls somewhere
between "private" and "protected".  Package protection is specified not by
using the word "package", but by using no modifier at all.  Variables are
package by default unless declared public, private, or protected.
</p>
<p>
A class or variable with package protection is visible to any class in the same
package, but not to classes outside the package (i.e., files outside the
directory).  The files in a package are presumed to trust each other, and are
usually implemented by the same person.  Files outside the package can only see
the public classes, methods, and fields.  (Subclasses outside the package can
see the protected methods and fields as well.)
</p>
<p>
Before we knew about packages, we had to make the fields of SListNode public so
that SList could manipulate them.  Our list package above solves this problem
by giving SListNode and its fields package protection, so that the SList class
may use SListNodes freely, but outside applications cannot access them.
</p>
<p>
In Homework 4, you'll see a different approach.  There, the DListNode class is
public, so that DListNodes can be directly held by application programs, but
the "prev" and "next" fields have package protection, so an application cannot
access these fields or corrupt the DList ADT.  But an application can hop
quickly from node to node because it can store DListNode references and use
them as parameters in DList method calls.
</p>
<p>
Each public class must be declared in a file named after the class, but a class
with package protection can be declared in any .java file (usually found
together with a class that uses it).  So a public SList class and a package
SListNode class can both be declared in the file list/SList.java, if you feel
like it.
</p>
<p>
Compiling and running files in a package is a bit tricky, because it must be
done from outside the package, using the following syntax:
</p>



<pre class="src src-java">javac -g list/SList.java
java <span style="color: #e5786d;">list</span>.SList
</pre>


<p>
Here's the correspondence between declarations and their visibility.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Visible:</th><th scope="col" class="left">in the same package</th><th scope="col" class="left">in a subclass</th><th scope="col" class="left">everywhere</th></tr>
</thead>
<tbody>
<tr><td class="left">Declaration</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">"public"</td><td class="left">X</td><td class="left">X</td><td class="left">X</td></tr>
<tr><td class="left">"protected"</td><td class="left">X</td><td class="left">X</td><td class="left"></td></tr>
<tr><td class="left">default (package)</td><td class="left">X</td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">"private"</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
</tbody>
</table>



</div>
</div>

</div>

<div id="outline-container-12-2" class="outline-3">
<h3 id="sec-12-2"><span class="section-number-3">12.2</span> ITERATORS</h3>
<div class="outline-text-3" id="text-12-2">

<p>In java.util there is a standard Java interface for iterating over sequences of
objects.
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">interface</span> <span style="color: #92a65e; font-weight: bold;">Iterator</span> {
  <span style="color: #92a65e; font-weight: bold;">boolean</span> <span style="color: #cae682;">hasNext</span>();
  <span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">next</span>();
  <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">remove</span>();                          <span style="color: #99968b;">// </span><span style="color: #99968b;">The remove() method is optional.</span>
}
</pre>


<p>
Part of Project 1 is to write a class RunIterator that implements an Iterator
for your RunLengthEncoding class.  Its purpose is to provide an interface by
which other classes can read the runs in your run-length encoding, one by one.
</p>
<p>
An Iterator is like a bookmark.  Just as you can have many bookmarks in a book,
you can have many Iterators iterating over the same data structure, each one
independent of the others.  One Iterator can advance without disturbing other
Iterators that are iterating over the same data structure.
</p>
<p>
The first time next() is called on a newly constructed Iterator, it returns the
first item in the sequence.  Each subsequent time next() is called, it returns
the next item in the sequence.  After the Iterator has returned every item in
the sequence, every subsequent call to next() throws an exception and halts
with an error message.  (I find this annoying; I would prefer an interface in
which next() returns null.  The Java library designers disagree.)
</p>
<p>
To help you avoid triggering an exception, hasNext() returns true if the
Iterator has more items to return, or false if it has already returned every
item in the sequence.  It is usually considered good practice to check
hasNext() before calling next().  (In the next lecture we'll learn how to catch
exceptions; that will give us an alternative way to prevent our program from
crashing when next() throws an exception.)
</p>
<p>
There is usually no way to reset an Iterator back to the beginning of the
sequence.  Instead, you construct a new Iterator.
</p>
<p>
Most data structures that support Iterators "implement" another interface in
java.util called "Iterable".  
</p>



<pre class="src src-java"><span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">interface</span> <span style="color: #92a65e; font-weight: bold;">Iterable</span> {
  <span style="color: #92a65e; font-weight: bold;">Iterator</span> <span style="color: #cae682;">iterator</span>();
}
</pre>


<p>
It is customary for applications that want to iterate over a data structure DS
to call DS.iterate(), which constructs and returns a DSIterator whose fields
are initialized so it is ready to return the first item in DS.
</p>
<p>
A benefit of creating an Iterable class with its own Iterator is that Java has
a simple built-in loop syntax, a second kind of "for each" loop, that iterates
over the items in a data structure.  Suppose we design an SList that implements
Iterator.  The following loop (which can appear in any class) iterates through
the items in an SList l.
</p>



<pre class="src src-java">  <span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">o</span> : l) {
    System.out.println(o);
  }

This loop is <span style="color: #92a65e; font-weight: bold;">equivalent</span> <span style="color: #cae682;">to</span>

  <span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">Iterator</span> <span style="color: #cae682;">i</span> = l.iterator(); i.hasNext(); ) {
    <span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">o</span> = i.next();
    System.out.println(o);
  }
</pre>


<p>
To make all this more concrete, here is a complete implementation of an
SListIterator class and a partial implementation of SList, both in the "list"
package.
</p>



<pre class="src src-java"><span style="color: #99968b;">/* </span><span style="color: #99968b;">list/SListIterator.java */</span>

<span style="color: #8ac6f2; font-weight: bold;">package</span> <span style="color: #63b8ff;">list</span>;
<span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #63b8ff;">java.util.*</span>;

<span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">SListIterator</span> <span style="color: #8ac6f2; font-weight: bold;">implements</span> <span style="color: #92a65e; font-weight: bold;">Iterator</span> {
  <span style="color: #92a65e; font-weight: bold;">SListNode</span> <span style="color: #cae682;">n</span>;

  <span style="color: #b0c4de;">public</span> <span style="color: #b0c4de;">SListIterator</span>(<span style="color: #92a65e; font-weight: bold;">SList</span> <span style="color: #cae682;">l</span>) {
    n = l.head;
  }

  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">boolean</span> <span style="color: #cae682;">hasNext</span>() {
    <span style="color: #8ac6f2; font-weight: bold;">return</span> n != <span style="color: #7fffd4;">null</span>;
  }

  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">next</span>() {
    <span style="color: #8ac6f2; font-weight: bold;">if</span> (n == <span style="color: #7fffd4;">null</span>) {
      <span style="color: #99968b;">/* </span><span style="color: #99968b;">We'll learn about throwing exceptions in the next lecture. */</span>
      <span style="color: #8ac6f2; font-weight: bold;">throw</span> <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">NoSuchElementException</span>();                       <span style="color: #99968b;">// </span><span style="color: #99968b;">In java.util</span>
    }
    <span style="color: #92a65e; font-weight: bold;">Object</span> <span style="color: #cae682;">i</span> = n.item;
    n = n.next;
    <span style="color: #8ac6f2; font-weight: bold;">return</span> i;
  }

  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">remove</span>() {
    <span style="color: #99968b;">/* </span><span style="color: #99968b;">Doing it the lazy way.  Remove this, motherf! */</span>
    <span style="color: #8ac6f2; font-weight: bold;">throw</span> <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">UnsupportedOperationException</span>(<span style="color: #95e454;">"Nice try, bozo."</span>); <span style="color: #99968b;">// </span><span style="color: #99968b;">In java.lang</span>
  }
}

<span style="color: #99968b;">/* </span><span style="color: #99968b;">list/SList.java */</span>

<span style="color: #8ac6f2; font-weight: bold;">package</span> <span style="color: #63b8ff;">list</span>;
<span style="color: #8ac6f2; font-weight: bold;">import</span> <span style="color: #63b8ff;">java.util.*</span>;

<span style="color: #b0c4de;">public</span> <span style="color: #8ac6f2; font-weight: bold;">class</span> <span style="color: #92a65e; font-weight: bold;">SList</span> <span style="color: #8ac6f2; font-weight: bold;">implements</span> <span style="color: #92a65e; font-weight: bold;">Iterable</span> {
  <span style="color: #92a65e; font-weight: bold;">SListNode</span> <span style="color: #cae682;">head</span>;
  <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">size</span>;

  <span style="color: #b0c4de;">public</span> <span style="color: #92a65e; font-weight: bold;">Iterator</span> <span style="color: #cae682;">iterator</span>() {
    <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #8ac6f2; font-weight: bold;">new</span> <span style="color: #92a65e; font-weight: bold;">SListIterator</span>(<span style="color: #8ac6f2; font-weight: bold;">this</span>);
  }

  [other methods here]
}
</pre>


<p>
Observe that an Iterator may mess up or even crash the program if the
structure it is iterating over changes.  For example, if the node "n" that an
SListIterator references is removed from the list, the SListIterator will not
be able to find the rest of the nodes.
</p>
<p>
An Iterator doesn't have to iterate over a data structure.  For example, you
can implement an Iterator subclass called Primes that returns each successive
prime number as an Integer object.
</p></div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-02-22T14:37-0800</p>
<p class="author">Author: michael</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.2 with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
