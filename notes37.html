<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>notes37</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="notes37"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-05-07T21:59-0700"/>
<meta name="author" content="michael"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: courier, monospace; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
        padding: 5pt;
        font-family: courier, monospace;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
/**
 *
 * @source: http://orgmode.org/mathjax/MathJax.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 * Copyright (C) 2012-2013  MathJax
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in http://orgmode.org/mathjax/MathJax.js.
 *
 */

/*
@licstart  The following is the entire license notice for the
JavaScript code below.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code below is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code below.
*/
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">notes37</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Lecture 37</a>
<ul>
<li><a href="#sec-1-1">AMORTIZED ANALYSIS</a></li>
<li><a href="#sec-1-2">The Averaging Method</a></li>
<li><a href="#sec-1-3">The Accounting Method</a></li>
<li><a href="#sec-1-4">Accounting of Hash Tables</a></li>
<li><a href="#sec-1-5">Why Does Amortized Analysis Work?</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Lecture 37</h2>
<div class="outline-text-2" id="text-1">


<p>
<a href="original-notes/37.txt">original notes</a>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">AMORTIZED ANALYSIS</h3>
<div class="outline-text-3" id="text-1-1">

<p>We've seen several data structures for which I claimed that the average time
for certain operations is always better than the worst-case time:  hash tables,
tree-based disjoint sets, and splay trees.
</p>
<p>
The mathematics that proves these claims is called <span style="text-decoration:underline;">amortized analysis</span>.
Amortized analysis is a way of proving that even if an operation is
occasionally expensive, its cost is made up for by earlier, cheaper operations.
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">The Averaging Method</h3>
<div class="outline-text-3" id="text-1-2">

<p>Most hash table operations take \(O(1)\) time, but sometimes an operation forces
a hash table to resize itself, at great expense.  What is the average time to
insert an item into a hash table with resizing?  Assume that the chains never
grow longer than \(O(1)\), so any operation that doesn't resize the table takes
\(O(1)\) time&ndash;more precisely, suppose it takes at most one second.
</p>
<p>
Let \(n\) be the number of items in the hash table, and \(N\) the number of buckets.
Suppose it takes one second for the insert operation to insert the new item,
increment \(n\), and then check if \(n = N\).  If so, it doubles the size of the table
from N to 2N, taking 2N additional seconds.  This resizing scheme ensures that
the load factor \(\frac{n}{N}\) is always less than one.
</p>
<p>
Suppose every newly constructed hash table is empty and has just one bucket--
that is, initially \(n = 0\) and \(N = 1n = 0\).  After \(i\) insert operations, \(n = i\).  The
number of buckets \(N\) must be a power of two, and we never allow it to be less
than or equal to n; so \(N\) is the smallest power of two \(&gt; n\), which is \(\le 2n\).
</p>
<p>
The total time in seconds for <span style="text-decoration:underline;">all</span> the table resizing operations is
</p>
<p>
    $$2 + 4 + 8 + ... + \frac{N}{4} + \frac{N}{2} + N = 2N - 2.$$
</p>
<p>
So the cost of \(i\) insert operations is at most \(i + 2N - 2\) seconds.  Because
\(N \le 2n = 2i\), the \(i\) insert operations take \(\le 5i - 2\) seconds.  Therefore, the
<span style="text-decoration:underline;">average</span> running time of an insertion operation is \(\frac{5i - 2}{i} = 5 - \frac{2}{i}\)
seconds, which is in \(O(1)\) time.
</p>
<p>
We say that the <span style="text-decoration:underline;">amortized running time</span> of insertion is in \(O(1)\), even though
the worst-case running time is in \(\mathrm{Theta}(n)\).
</p>
<p>
For almost any application, the amortized running time is more important than
the worst-case running time, because the amortized running time determines the
total running time of the application.  The main exceptions are some
applications that require fast interaction (like video games), for which one
really slow operation might cause a noticeable glitch in response time.
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">The Accounting Method</h3>
<div class="outline-text-3" id="text-1-3">

<p>Consider hash tables that resize in both directions:  not only do they expand
as the number of items increases, but they also shrink as the number of items
decreases.  You can't analyze them with the averaging method, because you don't
know what sequence of insert and remove operations an application might
perform.
</p>
<p>
Let's try a more sophisticated method.  In the <span style="text-decoration:underline;">accounting method</span>, we "charge"
each operation a certain amount of time.  Usually we overcharge.  When we
charge more time than the operation actually takes, we can save the excess time
in a bank to spend on later operations.
</p>
<p>
Before we start, let's stop using seconds as our unit of running time.  We
don't actually know how many seconds any computation takes, because it varies
from computer to computer.  However, everything a computer does can be broken
down into a sequence of constant-time computations.  Let a <span style="text-decoration:underline;">dollar</span> be a unit
of time that's long enough to execute the slowest constant-time computation
that comes up in the algorithm we're analyzing.  A dollar is a real unit of
time, but it's different for different computers.
</p>
<p>
Each hash table operation has
</p><ul>
<li>an <span style="text-decoration:underline;">amortized cost</span>, which is the number of dollars that we "charge" to do
  that operation, and
</li>
<li>an <span style="text-decoration:underline;">actual cost</span>, which is the actual number of constant-time computations
  the operation performs.
</li>
</ul>


<p>
The amortized cost is usually a fixed function of n (e.g. $5 for insertion into
a hash table, or $2 log n for insertion into a splay tree), but the actual cost
may vary wildly from operation to operation.  For example, insertion into a
hash table takes a long, long time when the table is resized.
</p>
<p>
When an operation's amortized cost exceeds its actual cost, the extra dollars
are saved in the bank to be spent on later operations.  When an operation's
actual cost exceeds its amortized cost, dollars are withdrawn from the bank to
pay for an unusually expensive operation.
</p>
<p>
If the bank balance goes into surplus, it means that the actual total running
time is even faster than the total amortized costs imply.
</p>
<p>
THE BANK BALANCE MUST NEVER FALL BELOW ZERO.  If it does, you are spending more
total dollars than your budget claims, and you have failed to prove anything
about the amortized running time of the algorithm.
</p>
<p>
Think of amortized costs as an allowance.  If your dad gives you $500 a month
allowance, and you only spend $100 of it each month, you can save up the
difference and eventually buy a car.  The car may cost $30,000, but if you
saved that money and don't go into debt, your <span style="text-decoration:underline;">average</span> spending obviously
wasn't more than $500 a month.
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">Accounting of Hash Tables</h3>
<div class="outline-text-3" id="text-1-4">

<p>Suppose every operation (insert, find, remove) takes one dollar of actual
running time unless the hash table is resized.  We resize the table in two
circumstances.
</p><ul>
<li>An insert operation doubles the table size if \(n = N\) AFTER the new item is
  inserted and n is incremented, taking 2N additional dollars of time for
  resizing to 2N buckets.  Thus, the load factor is always less than one.
</li>
<li>The remove operation halves the table size if \(n = \frac{N}{4}\) AFTER the item is
  deleted and \(n\) is decremented, taking \(N\) additional dollars of time for
  resizing to \(\frac{N}{2}\) buckets.  Thus, the load factor is always greater than 0.25
  (except when \(n = 0\), i.e. the table is empty).
</li>
</ul>


<p>
Either way, a hash table that has <span style="text-decoration:underline;">just</span> been resized has \(n = \frac{N}{2}\).
A newly constructed hash table has \(n = 0\) items and \(N = 1\) buckets.
</p>
<p>
By trial and error, I came up with the following amortized costs.
</p>
<p>
    insert:  5 dollars<br/>
    remove:  5 dollars<br/>
    find:    1 dollar
</p>
<p>
Is this accounting valid, or will we go broke?
</p>
<p>
The crucial insight is that at any time, we can look at a hash table and know a
lower bound for how many dollars are in the bank from the values of n and N.
We know that the last time the hash table was resized, the number of items n
was exactly \(\frac{N}{2}\).  So if \(n \ne \frac{N}{2}\), there have been subsequent insert/remove
operations, and these have put money in the bank.
</p>
<p>
We charge an amortized $5 for an insert or remove operation.  Every insert or
remove operation costs one actual dollar (not counting resizing) and puts the
remaining $4 in the bank to pay for resizing.  For every step n takes away from
\(\frac{N}{2}\), we accumulate another $4.  So there must be at least \(4|n - \frac{N}{2}|\) dollars
saved (or \(4n\) dollars for a never-resized one-bucket hash table).
</p>
<p>
IMPORTANT:  Note that \(4|n - \frac{N}{2}|\) is a function of the data structure, and does
NOT depend on the history of hash table operations performed.  In general, the
accounting method only works if you can tell how much money is in the bank (or,
more commonly, a minimum bound on that bank balance) just by looking at the
current state of the data structure&ndash;without knowing how the data structure
reached that state.
</p>
<p>
An insert operation only resizes the table if the number of items n reaches N.
According to the formula \(4|n - \frac{N}{2}|\), there are at least 2N dollars in the bank.
Resizing the hash table from \(N\) to \(2N\) buckets costs \(2N\) dollars, so we can afford
it.  After we resize, the bank balance might be zero again, but it isn't
negative.
</p>
<p>
A remove operation only resizes the table if the number of items n drops to
\(\frac{N}{4}\).  According to the formula \(4|n - \frac{N}{2}|\), there are at least \(N\) dollars in the
bank.  Resizing the hash table from \(N\) to \(\frac{N}{2}\) buckets costs \(N\) dollars, so we can
afford it.
</p>
<p>
The bank balance never drops below zero, so my amortized costs above are valid.
Therefore, the amortized cost of all three operations is in \(O(1)\).
</p>
<p>
Observe that if we alternate between inserting and deleting the same item over
and over, the hash table is never resized, so we save up a lot of money in the
bank.  This isn't a problem; it just means the algorithm is faster (spends
fewer dollars) than my amortized costs indicate.
</p>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">Why Does Amortized Analysis Work?</h3>
<div class="outline-text-3" id="text-1-5">

<p>Why does this metaphor about putting money in the bank tell us anything about
the actual running time of an algorithm?
</p>
<p>
Suppose our accountant keeps a ledger with two columns:  the total amortized
cost of all operations so far, and the total actual cost of all operations so
far.  Our bank balance is the sum of all the amortized costs in the left
column, minus the sum of all the actual costs in the right column.  If the bank
balance never drops below zero, the total actual cost is less than or equal to
the total amortized cost.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Total amortized cost</th><th scope="col" class="left">Total actual cost</th></tr>
</thead>
<tbody>
<tr><td class="left">$5</td><td class="left">$1</td></tr>
<tr><td class="left">$1</td><td class="left">$1</td></tr>
<tr><td class="left">$5</td><td class="left">$3</td></tr>
<tr><td class="left">.</td><td class="left">.</td></tr>
<tr><td class="left">.</td><td class="left">.</td></tr>
<tr><td class="left">.</td><td class="left">.</td></tr>
<tr><td class="left">$5</td><td class="left">$1</td></tr>
<tr><td class="left">$5</td><td class="left">$2,049</td></tr>
<tr><td class="left">$1</td><td class="left">$1</td></tr>
</tbody>
<tbody>
<tr><td class="left">$12,327</td><td class="left">&gt;=       $10,333</td></tr>
</tbody>
</table>



<p>
Therefore, the total running time of all the actual operations is never longer
than the total amortized cost of all the operations.
</p>
<p>
Amortized analysis (as presented here) only tells us an upper bound (big-Oh) on
the actual running time, and not a lower bound (big-Omega).  It might happen
that we accumulate a big bank balance and never spend it, and the total actual
running time might be much less than the amortized cost.  For example, splay
tree operations take amortized \(O(\log n)\) time, where \(n\) is the number of items in
the tree, but if your only operation is to find the same item \(n\) times in a row,
the actual average running time is in \(O(1)\).
</p>
<p>
If you want to see the amortized analysis of splay trees, Goodrich and Tamassia
have it.  If you take CS 170, you'll see an amortized analysis of disjoint
sets.  I am saddened to report that both analyses are too complicated to
provide much intuition about their running times.  (Especially the inverse
Ackermann function, which is ridiculously nonintuitive, though cool
nonetheless.)
</p></div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-05-07T21:59-0700</p>
<p class="author">Author: michael</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
