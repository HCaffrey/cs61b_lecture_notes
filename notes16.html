<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>notes16</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="notes16"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-03-15T15:09-0700"/>
<meta name="author" content="michael"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	padding: 5pt;
	font-family: courier, monospace;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">notes16</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Lecture 16</a>
<ul>
<li><a href="#sec-1-1">EXCEPTIONS (continued)</a>
<ul>
<li><a href="#sec-1-1-1">The "finally" keyword</a></li>
<li><a href="#sec-1-1-2">Exception constructors</a></li>
</ul>
</li>
<li><a href="#sec-1-2">GENERICS</a></li>
<li><a href="#sec-1-3">FIELD SHADOWING</a></li>
<li><a href="#sec-1-4">"final" METHODS AND CLASSES</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Lecture 16</h2>
<div class="outline-text-2" id="text-1">


<p>
Today's reading:  Sierra &amp; Bates, pp. 189, 283.
</p>
<p>
<a href="original-notes/16">original notes</a>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">EXCEPTIONS (continued)</h3>
<div class="outline-text-3" id="text-1-1">


</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">The "finally" keyword</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>A finally clause can also be added to a "try."
</p>



<pre class="example">FileInputStream f = new FileInputStream("filename");
try {
    statementX;
    return 1;
} catch (IOException e) {
    e.printStackTrace();
    return 2;
} finally {
    f.close();
}
</pre>


<p>
If the "try" statement begins to execute, the "finally" clause will be executed
at the end, no matter what happens.  "finally" clauses are used to do things
that need to be done in both normal and exceptional circumstances.
In this example, it is used to close a file.
</p>
<p>
If statementX causes no exception, then the "finally" clause is executed, and
1 is returned.
</p>
<p>
If statementX causes a IOException, the exception is caught, the "catch"
clause is executed, and then the "finally" clause is executed.  After the
"finally" clause is done, 2 is returned.
</p>
<p>
If statementX causes some other class of exception, the "finally" clause is
executed immediately, then the exception continues to propagate down the stack.
</p>
<p>
In the example above, we've invoked the method "printStackTrace" on the
exception we caught.  When an exception is constructed, it takes a snapshot of
the stack, which can be printed later.
</p>
<p>
It is possible for an exception to occur in a "catch" or "finally" clause.  An
exception thrown in a "catch" clause will terminate the "catch" clause, but the
"finally" clause will still get executed before the exception goes on.  An
exception thrown in a "finally" clause replaces the old exception, and
terminates the "finally" clause and the method immediately.
</p>
<p>
However&hellip;you can nest a "try" clause inside a "catch" or "finally" clause,
thereby catching those exceptions as well.
</p>
</div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Exception constructors</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>By convention, most Throwables (including Exceptions) have two constructors.
One takes no parameters, and one takes an error message in the form of a
String.
</p>



<pre class="example">class MyException extends Exception {
    public MyException() { super(); }
    public MyException(String s) { super(s); }
}
</pre>


<p>
The error message will be printed if it propagates out of main(), and it can be
read by the Throwable.getMessage() method.  The constructors usually call the
superclass constructors, which are defined in Throwable.
</p>
</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">GENERICS</h3>
<div class="outline-text-3" id="text-1-2">

<p>Suppose you're using a list of Objects to store Strings.  When you fetch a
String from the list, you have to cast it back to type "String" before you can
call the methods exclusive to Strings.  If somehow an object that's not a
String got into your list, the cast will throw an exception.  It would be nice
to have the compiler enforce the restriction that nothing but Strings can ever
get into your list in the first place, so you can sleep at night knowing that
your family is safe from a ClassCastException.
</p>
<p>
So Java offers <span style="text-decoration:underline;">generics</span>, which allow you to declare general classes that
produce specialized objects.  For example, you can create an SList for Strings
only, and another SList for Integers only, even though you only wrote one
SList class.  To specify the class, SList takes a <span style="text-decoration:underline;">type parameter</span>.
</p>



<pre class="example">class SListNode&lt;T&gt; {                         // T is the formal parameter.
    T item;
    SListNode&lt;T&gt; next;

    SListNode(T i, SListNode&lt;T&gt; n) {
        item = i;
        next = n;
    }
}

public class SList&lt;T&gt; {
    SListNode&lt;T&gt; head;

    public void insertFront(T item) {
        head = new SListNode&lt;T&gt;(item, head);
    }
}
</pre>


<p>
You can now create and use an SList of Strings as follows.
</p>



<pre class="example">SList&lt;String&gt; l = new SList&lt;String&gt;();     // String is the actual parameter.
l.insertFront("Hello");
</pre>


<p>
Likewise, you can create an SList of Integers by using "SList&lt;Integer&gt;" in the
declaration and constructor.
</p>
<p>
What are the advantages of generics?  First, the compiler will ensure at
compile-time that nothing but Strings can ever enter your SList&lt;String&gt;.
Second, you don't have to cast the Objects coming out of your SList back to
Strings, so there is no chance of an unexpected ClassCastException at run time.
If some bug in your program is trying to put Integer objects into your SList,
it's much easier to diagnose the compiler refusing to put an Integer into an
SList&lt;String&gt; than it is to diagnose a ClassCastException occurring when you
remove an Integer from a regular SList and try to cast it to String.
</p>
<p>
Generics are a complicated subject.  Consider this to be a taste of them;
hardly a thorough treatment.  A good tutorial is available at
<a href="https://www.seas.upenn.edu/~cis1xx/resources/generics-tutorial.pdf">https://www.seas.upenn.edu/~cis1xx/resources/generics-tutorial.pdf</a> .
</p>
<p>
Although Java generics are superficially similar to C++ templates, there's a
crucial difference between them.  In the example above, Java compiles bytecode
for only a single SList class.  This SList bytecode can be used by all
different object types.  It is the compiler, not the bytecode itself, that
enforces the fact that a particular SList object can only store objects of a
particular class.  Conversely, C++ recompiles the SList methods for every type
that you instantiate SLists on.  The C++ disadvantage is that one class might
turn into a lot of machine code.  The C++ advantages are that you can use
primitive types, and you get code optimized for each type.  Java generics don't
work with primitive types.
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">FIELD SHADOWING</h3>
<div class="outline-text-3" id="text-1-3">

<p>Just as methods can be overridden in subclasses, fields can be "shadowed" in
subclasses.  However, shadowing works quite differently from overriding.
Whereas the choice of methods is dictated by the <span style="text-decoration:underline;">dyanamic type</span> of an object,
the choice of fields is dictated by the <span style="text-decoration:underline;">static type</span> of a variable or object.
</p>



<pre class="example">class Super {
    int x = 2;
    int f() {
        return 2;
    }
}

class Sub extends Super {
    int x = 4;                // shadows Super.x
    int f() {                 // overrides Super.f()
        return 4;
    }
}
</pre>


<p>
Any object of class Sub now has <span style="text-decoration:underline;">two</span> fields called x, each of which store a
different integer.  How do we know which field is accessed when we refer to x?
It depends on the static type of the expression whose x field is accessed.
</p>



<pre class="example">Sub sub = new Sub();
Super supe = sub;       // supe and sub reference the same object.
int i;
</pre>


<p>
<img src="ditaa-images/img1_94820ad169bdad9b7d8af324c3961a17fac45c61.png"  alt="ditaa-images/img1_94820ad169bdad9b7d8af324c3961a17fac45c61.png" />
</p>



<pre class="example">i = supe.x;             // 2
i = sub.x;              // 4
i = ((Super) sub).x;    // 2
i = ((Sub) supe).x;     // 4
</pre>


<p>
The last four statements all use the same object, but yield different results.
Recall that method overriding does not work the same way.  Since both variables
reference a Sub, the method Sub.f always overrides Super.f.
</p>



<pre class="example">i = supe.f();           // 4
i = sub.f();            // 4
i = ((Super) sub).f();  // 4
i = ((Sub) supe).f();   // 4
</pre>


<p>
What if the variable whose shadowed field you want to access is "this"?
You can cast "this" too, but a simpler alternative is to replace "this" with
"super".
</p>



<pre class="example">class Sub extends Super {
    int x = 4;                  // shadows Super.x
    void g() {
        int i;

        i = this.x;             // 4
        i = ((Super) this).x    // 2
            i = super.x;        // 2
    }
}
</pre>


<p>
Whereas method overriding is a powerful benefit of object orientation, field
shadowing is largely a nuisance.  Whenever possible, avoid having fields in
subclasses whose names are the same as fields in their superclasses.
</p>
<p>
Static methods can be shadowed too; they follow the same shadowing rules as
fields.  This might seem confusing:  why do ordinary, non-static methods use
one system (overriding) while static methods use an entirely different system
(shadowing)?  The reason is because overriding requires dynamic method lookup.
Dynamic method lookup looks up the dynamic type of an object.  A static method
is not called on an object, so there's nothing whose dynamic type we can look
up.  Therefore, static methods <span style="text-decoration:underline;">can't</span> use dynamic method lookup or overriding.
So they use shadowing instead.
</p>
<p>
Static method shadowing, like field shadowing, is largely a nuisance.
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">"final" METHODS AND CLASSES</h3>
<div class="outline-text-3" id="text-1-4">

<p>A method can be declared "final" to prevent subclasses from overriding it.  Any
attempt to override it will cause a compile-time error.
</p>
<p>
A class can be declared "final" to prevent it from being extended.  Any attempt
to declare a subclass will cause a compile-time error.
</p>
<p>
The only reason to declare a method or class "final" is to improve the speed of
a program.  The compiler can speed up method calls that cannot be overridden.
</p></div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-03-15T15:09-0700</p>
<p class="author">Author: michael</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
