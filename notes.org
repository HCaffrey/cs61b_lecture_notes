#+TITLE: cs61b Lecture Notes
#+STARTUP: overview

* Lecture 2
Friday, January 24, 2014

Today's reading:  Sierra & Bates, Chapter 2; pp. 54-58, 154-160, 661, 669.
** OBJECTS AND CONSTRUCTORS

#+Begin_SRC java
String s;           // Step 1:      declare a String variable.
s = new String();   // Steps 2, 3:  construct new empty String; assign it to s.
#+END_SRC  

At this point, s is a variable that 
references an "empty" String, i.e.  
a String containing zero characters. 
#+begin_ditaa ditaa-images/img10
          +-+     +----+
        s |.+---->|    |
          +-+     +----+
#+end_ditaa
#+Begin_SRC java
String s = new String();  // Steps 1, 2, 3 combined.
s = "Yow!";               // Construct a new String; make s a reference to it.
#+END_SRC

#+begin_ditaa ditaa-images/img3
          +-+     +--------+
        s |.+---->|  Yow!  |
          +-+     +--------+
#+end_ditaa

#+Begin_SRC java
String s2 = s;            // Copy the reference stored in s into s2.
#+END_SRC

#+begin_ditaa ditaa-images/img4
          +-+     +--------+     +-+   
        s |.+---->|  Yow!  |<----+.| s2
          +-+     +--------+     +-+
#+end_ditaa

Now s and s2 reference the same object.

#+Begin_SRC java
s2 = new String(s);       // Construct a copy of object; store reference in s2.
#+END_SRC

#+begin_ditaa ditaa-images/img5
          +-+     +--------+       +-+     +--------+
        s |.+---->|  Yow!  |    s2 |.+---->|  Yow!  |
          +-+     +--------+       +-+     +--------+
#+end_ditaa

Now they refer to two different, but identical, objects.

Think about that.  When Java executes that line, it does the following things,
in the following order.
- Java looks inside the variables to see where it's pointing.
- Java follows the pointer to the String object.
- Java reads the characters stored in that String object.
- Java creates a new String object that stores a copy of those characters.
- Java stores a reference to the new String object in s2.

We've seen three String constructors:
  1.  new String() constructs an _empty string_--it's a string, but it
       contains zero characters.
  2.  "Yow!" constructs a string containing the characters Yow!.
  3.  new String(s) takes a _parameter_ s.  Then it makes a copy of the object
       that s references.

Constructors _always_ have the same name as their class, except the special
constructor "stuffinquotes".  That's the only exception.

Observe that "new String()" can take no parameters, or one parameter.  These
are two different constructors--one that is called by "new String()", and one
that is called by "new String(s)".  (Actually, there are many more than
two--check out the online Java API to see all the possibilities.)

** METHODS
Let's look at some methods that aren't constructors.

#+Begin_SRC java
s2 = s.toUppercase();       // Create a string like s, but in all upper case.
#+END_SRC

#+begin_ditaa ditaa-images/img6
   +-+     +--------+
s2 |.+---->|  YOW!  |
   +-+     +--------+
#+end_ditaa

#+Begin_SRC java
String s3 = s2.concat("!!");             // Also written:  s3 = s2 + "!!";
#+END_SRC

#+begin_ditaa ditaa-images/img7
   +-+     +----------+
s3 |.+---->|  YOW!!!  |
   +-+     +----------+
#+end_ditaa

#+Begin_SRC java
String s4 = "*".concat(s2).concat("*");  // Also written:  s4 = "*" + s + "*";
#+END_SRC

#+begin_ditaa ditaa-images/img8
   +-+     +----------+
s4 |.+---->|  *YOW!*  |
   +-+     +----------+
#+end_ditaa

Now, here's an important fact:  when Java executed the line

#+Begin_SRC java
  s2 = s.toUppercase();
#+END_SRC

the String object "Yow!" did _not_ change.  Instead, s2 itself changed to
reference a new object.  Java wrote a new "pointer" into the variable s2, so
now s2 points to a different object than it did before.

Unlike in C, in Java Strings are _immutable_--once they've been constructed,
their contents never change.  If you want to change a String object, you've got
to create a brand new String object that reflects the changes you want.  This
is not true of all objects; most Java objects let you change their contents.

You might find it confusing that methods like "toUppercase" and "concat" return
newly created String objects, though they are not constructors.  The trick is
that those methods calls constructors internally, and return the newly
constructed Strings.

** I/O Classes and Objects in Java

Here are some objects in the System class for interacting with a user:

  System.out is a PrintStream object that outputs to the screen.
  System.in is an InputStream object that reads from the keyboard.
    [Reminder:  this is shorthand for "System.in is a variable that references
                an InputStream object."]

But System.in doesn't have methods to read a line directly.  There is a method
called readLine that does, but it is defined on BufferedReader objects.

- How do we construct a BufferedReader?  One way is with an InputStreamReader.
- How do we construct an InputStreamReader?  We need an InputStream.
- How do we construct an InputStream?  System.in is one.
(You can figure all of this out by looking at the constructors in the online
Java libraries API--specifically, in the java.io library.)

Why all this fuss?

InputStream objects (like System.in) read raw data from some source (like the
keyboard), but don't format the data.

InputStreamReader objects compose the raw data into characters (which are
typically two bytes long in Java).

BufferedReader objects compose the characters into entire lines of text.

Why are these tasks divided among three different classes?  So that any one
task can be reimplemented (say, for improved speed) without changing the other
two.

Here's a complete Java program that reads a line from the keyboard and prints
it on the screen.

#+Begin_SRC java
  import java.io.*;
  
  class SimpleIO {
      public static void main(String[] arg) throws Exception {
          BufferedReader keybd =
              new BufferedReader(new InputStreamReader(System.in));
          System.out.println(keybd.readLine());
      }
  }
#+END_SRC

Don't worry if you don't understand the first three lines; we'll learn the
underlying ideas eventually.  The first line is present because to use the Java
libraries, other than java.lang, you need to "import" them.  java.io includes
the InputStreamReader and BufferedReader classes.

The second line just gives the program a name, "SimpleIO".

The third line is present because any Java program always begins execution at a
method named "main", which is usually defined more or less as above.  When you
write a Java program, just copy the line of code, and plan to understand it a
few weeks from now.

** Classes for Web Access

Let's say we want to read a line of text from the White House Web page.  (The
line will be HTML, which looks ugly.  You don't need to understand HTML.)

How to read a line of text?  With readLine on BufferedReader.
How to create a BufferedReader?  With an InputStreamReader.
How to create a InputStreamReader?  With an InputStream.
How to create an InputStream?  With a URL.

#+Begin_SRC java
  import java.net.*;
  import java.io.*;
  
  class WHWWW {
      public static void main(String[] arg) throws Exception {
          URL u = new URL("http://www.whitehouse.gov/");
          InputStream ins = u.openStream();
          InputStreamReader isr = new InputStreamReader(ins);
          BufferedReader whiteHouse = new BufferedReader(isr);
          System.out.println(whiteHouse.readLine());
      }
  }
#+END_SRC

** Postscript:  Object-Oriented Terminology (not examinable)

In the words of Turing Award winner Nicklaus Wirth, "Object-oriented
programming (OOP) solidly rests on the principles and concepts of traditional
procedural programming.  OOP has not added a single novel concept ... along
with the OOP paradigm came an entirely new terminology with the purpose of
mystifying the roots of OOP."  Here's a translation guide.

| Procedural Programming | Object-Oriented Programming                      |
|------------------------+--------------------------------------------------|
| record / structure     | object                                           |
| record type            | class                                            |
| extending a type       | declaring a subclass                             |
| procedure              | method                                           |
| procedure call         | sending a message to the method [ack!  phthhht!] |

I won't ever talk about "sending a message" in this class.  I think it's a
completely misleading metaphor.  In computer science, message-passing normally
implies asynchrony: that is, the process that sends a message can continue
executing while the receiving process receives the message and acts on it.
But that's NOT what it means in object-oriented programming:  when a Java
method "sends a message" to another method, the former method is frozen until
the latter methods completes execution, just like with procedure calls in most
languages.  But you should probably know that this termology exists, much as it
sucks, because you'll probably run into it sooner or later.

* Lecture 3
Monday, January 27, 2014

Today's reading:  Sierra & Bates, pp. 71-74, 76, 85, 240-249, 273-281, 308-309.

** DEFINING CLASSES
An object is a repository of data.  _Fields_ are variables that hold the data
stored in objects.  Fields in objects are also known as _instance variables_.
In Java, fields are addressed much like methods are, but fields never have
parameters, and no parentheses appear after them.  For example, suppose that
amanda is a Human object.  Then amanda.introduce() is a method call, and
amanda.age is a field.  Let's write a _class definition_ for the Human class.

#+Begin_SRC java
class Human {
  public int age;                // The Human's age (an integer).
  public String name;            // The Human's name.

  public void introduce() {      // This is a _method definition_.
    System.out.println("I'm " + name + " and I'm " + age + " years old.");
  }
}
#+END_SRC

"age" and "name" are both fields of a Human object.  Now that we've defined the
Human class, we can construct as many Human objects as we want.  Each Human
object we create can have different values of age and name.  We might create
amanda by executing the following code.

#+Begin_SRC java
  Human amanda = new Human();    // Create amanda.
  amanda.age = 6;                // Set amanda's fields.
  amanda.name = "Amanda";
  amanda.introduce();            // _Method call_ has amanda introduce herself.
#+END_SRC

#+begin_ditaa ditaa-images/img13
                    +------------+
                    |      +--+  |
             +-+    |  age | 6|  |
      amanda |.+--->|      +--+  |     +----------+
             +-+    | name | .+--|---->| "Amanda" |
                    |      +--+  |     +----------+
                    +------------+    a String object
                    a Human object
#+end_ditaa

The output is:    I'm Amanda and I'm 6 years old.

Why is it that, inside the definition of introduce(), we don't have to write
"amanda.name" and "amanda.age"?  When we invoke "amanda.introduce()", Java
remembers that we are calling introduce() _on_ the object that "amanda"
references.  The methods defined inside the Human class remember that we're
referring to amanda's name and age.  If we had written "rishi.introduce()", the
introduce method would print rishi's name and age instead.  If we want to mix
two or more objects, we can.

#+Begin_SRC java
class Human {
  // Include all the stuff from the previous definition of Human here.

  public void copy(Human original) {
    age = original.age;
    name = original.name;
  }
}
#+END_SRC

Now, "amanda.copy(rishi)" copies rishi's fields to amanda.

** Constructors
Let's write a constructor, a method that constructs a Human.  The constructor
won't actually contain code that does the creating; rather, Java provides a
brand new object for us right at the beginning of the constructor, and all you
have to write (if you want) in the constructor is code to initialize the new
object.

#+Begin_SRC java
class Human {
  // Include all the stuff from the previous definitions here.

  public Human(String givenName) {
    age = 6;
    name = givenName;
  }
}
#+END_SRC

Notice that the constructor is named "Human", and it returns an object of type
"Human".  This constructor is called whenever we write "new Human(s)", where s
is a String reference.  Now, we can shorten amanda's coming-out party to

#+Begin_SRC java
  Human amanda = new Human("Amanda");
  amanda.introduce();
#+END_SRC

These lines accomplish precisely the same result as amanda's previous four
lines.

You might ask...why were we able to create a Human object before we wrote a
constructor?  Java provides every class with a default constructor, which takes
no parameters and does no initializing.  Hence, when we wrote

#+Begin_SRC java
  Human amanda = new Human();
#+END_SRC

we created a new, blank Human.  If the default constructor were explicitly
written, it would look like this:

#+Begin_SRC java
  public Human() {
  }
#+END_SRC

Warning:  if you write your own Human constructor, even if it takes parameters,
the default constructor goes away.  If you want to have the default constructor
_and_ another constructor, you must define both explicitly.

You can override the default constructor by explicitly writing your own
constructor with no parameters.

#+Begin_SRC java
class Human {
  // Include all the stuff from the previous definitions here.

  public Human() {
    age = 0;
    name = "Untitled";
  }
}
#+END_SRC

** The "this" Keyword
A method invocation, like "amanda.introduce()", implicitly passes an object
(in this example, amanda) as a parameter called "this".  So we can rewrite our
last constructor as follows without changing its meaning.

#+Begin_SRC java
  public Human() {
    this.age = 0;
    this.name = "Untitled";
  }
#+END_SRC

In this case, "this" is optional.  However, if the parameters or local
variables of a method have the same name as the fields of an object, then the
former have priority, and the "this" keyword is needed to refer to the object's
fields.

#+Begin_SRC java
  public void change(int age) {
    String name = "Tom";

    this.age = age;
    this.name = name;
  }
#+END_SRC

When we call "amanda.change(11)", "this" is assigned the same value as "amanda"
before the change() method begins execution.

#+begin_ditaa ditaa-images/img14
                                                   Parameters & local variables
          +-+    +------------+                    of change()
   amanda |.+--->|      +--+  |                      +--+            +--+
          +-+    |  age | 6|  |<---------------------+. | this   age |11|
                 |      +--+  |     +----------+     +--+            +--+
                 | name | .+--|---->|  Amanda  |          +--+     +-------+
                 |      +--+  |     +----------+     name | .+---->|  Tom  |
                 +------------+                           +--+     +-------+
#+end_ditaa

Now, when Java executes "this.age = age", it overwrites the 6 with an 11.
When Java executes "this.name = name", it overwrites amanda's name as below.

#+begin_ditaa ditaa-images/img15
                                                   Parameters & local variables
          +-+    +------------+                    of change()
   amanda |.+--->|      +--+  |                      +--+            +--+
          +-+    |  age |11|  |<---------------------+. | this   age |11|
                 |      +--+  |     +----------+     +--+            +--+
                 | name | .+--|--\  |  Amanda  |          +--+
                 |      +--+  |  |  +----------+     name | .+---->+-------+
                 +------------+  |                        +--+     |  Tom  |
                                 \-------------------------------->+-------+

  +----------------------------------------------------+
  | IMPORTANT:  You CANNOT change the value of "this"! |
  +----------------------------------------------------+
#+end_ditaa

A statement like "this = amanda;" will trigger a compile-time error.

** The "static" Keyword
A _static field_ is a single variable shared by a whole class of objects; its
value does not vary from object to object.  For example, if "numberOfHumans" is
the number of Human objects that have been constructed, it is not appropriate
for each object to have its own copy of this number; every time a new Human is
created, we would have to update every Human.

If we declare a field "static", there is just one field for the whole class.
Static fields are also called _class variables_.

#+Begin_SRC java
class Human {
  public static int numberOfHumans;

  public int age;
  public String name;

  public Human() {
    numberOfHumans++;    // The constructor increments the number by one.
  }
}
#+END_SRC

If we want to look at the variable numberOfHumans from another class, we write
it in the usual notation, but we prefix it with the class name rather than the
name of a specific object.

#+Begin_SRC java
  int kids = Human.numberOfHumans / 4;  // Good.
  int kids = amanda.numberOfHumans / 4; // This works too, but has nothing to
                                        // do with amanda specifically.  Don't
                                        // do this; it's bad (confusing) style.
#+END_SRC

System.in and System.out are other examples of static fields.

Methods can be static too.  A _static method_ doesn't implicitly pass an object
as a parameter.

#+Begin_SRC java
  class Human {
    ...
    public static void printHumans() {
      System.out.println(numberOfHumans);
    }
  }
#+END_SRC

Now, we can call "Human.printHumans()" from another class.  We can also call
"amanda.printHumans()", and it works, but it's bad style, and amanda will NOT
be passed along as "this".

The main() method is always static, because when we run a program, we are not
passing an object in.

#+begin_ditaa ditaa-images/img16
  +-----------------------------------------------------+
  | IMPORTANT:  In a static method, THERE IS NO "this"! |
  +-----------------------------------------------------+
#+end_ditaa

Any attempt to reference "this" will cause a compile-time error.

** Lifetimes of Variables

- A local variable (declared in a method) is gone forever as soon as the method
  in which it's declared finishes executing.  (If it references an object, the
  object might continue to exist, though.)
- An instance variable (non-static field) lasts as long as the object exists.
  An object lasts as long as there's a reference to it.
- A class variable (static field) lasts as long as the program runs.
