<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>notes3</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="notes3"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-03-15T15:12-0700"/>
<meta name="author" content="michael"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	padding: 5pt;
	font-family: courier, monospace;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">notes3</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Lecture 3</a>
<ul>
<li><a href="#sec-1-1">DEFINING CLASSES</a></li>
<li><a href="#sec-1-2">Constructors</a></li>
<li><a href="#sec-1-3">The "this" Keyword</a></li>
<li><a href="#sec-1-4">The "static" Keyword</a></li>
<li><a href="#sec-1-5">Lifetimes of Variables</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Lecture 3</h2>
<div class="outline-text-2" id="text-1">

<p>Today's reading:  Sierra &amp; Bates, pp. 71-74, 76, 85, 240-249, 273-281, 308-309.
</p>
<p>
<a href="original-notes/03">original notes</a>
</p>
</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">DEFINING CLASSES</h3>
<div class="outline-text-3" id="text-1-1">

<p>An object is a repository of data.  <span style="text-decoration:underline;">Fields</span> are variables that hold the data
stored in objects.  Fields in objects are also known as <span style="text-decoration:underline;">instance variables</span>.
In Java, fields are addressed much like methods are, but fields never have
parameters, and no parentheses appear after them.  For example, suppose that
amanda is a Human object.  Then amanda.introduce() is a method call, and
amanda.age is a field.  Let's write a <span style="text-decoration:underline;">class definition</span> for the Human class.
</p>



<pre class="example">class Human {
    public int age;                // The Human's age (an integer).
    public String name;            // The Human's name.

    public void introduce() {      // This is a _method definition_.
        System.out.println("I'm " + name + " and I'm " + age + " years old.");
    }
}
</pre>


<p>
"age" and "name" are both fields of a Human object.  Now that we've defined the
Human class, we can construct as many Human objects as we want.  Each Human
object we create can have different values of age and name.  We might create
amanda by executing the following code.
</p>



<pre class="example">Human amanda = new Human();    // Create amanda.
amanda.age = 6;                // Set amanda's fields.
amanda.name = "Amanda";
amanda.introduce();            // _Method call_ has amanda introduce herself.
</pre>



<p>
<img src="ditaa-images/img13_27421ef0c82df17e5737f8428ec6e33f883f3823.png"  alt="ditaa-images/img13_27421ef0c82df17e5737f8428ec6e33f883f3823.png" />
</p>

<p>
The output is:    I'm Amanda and I'm 6 years old.
</p>
<p>
Why is it that, inside the definition of introduce(), we don't have to write
"amanda.name" and "amanda.age"?  When we invoke "amanda.introduce()", Java
remembers that we are calling introduce() <span style="text-decoration:underline;">on</span> the object that "amanda"
references.  The methods defined inside the Human class remember that we're
referring to amanda's name and age.  If we had written "rishi.introduce()", the
introduce method would print rishi's name and age instead.  If we want to mix
two or more objects, we can.
</p>



<pre class="example">class Human {
    // Include all the stuff from the previous definition of Human here.

    public void copy(Human original) {
        age = original.age;
        name = original.name;
    }
}
</pre>


<p>
Now, "amanda.copy(rishi)" copies rishi's fields to amanda.
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Constructors</h3>
<div class="outline-text-3" id="text-1-2">

<p>Let's write a constructor, a method that constructs a Human.  The constructor
won't actually contain code that does the creating; rather, Java provides a
brand new object for us right at the beginning of the constructor, and all you
have to write (if you want) in the constructor is code to initialize the new
object.
</p>



<pre class="example">class Human {
    // Include all the stuff from the previous definitions here.

    public Human(String givenName) {
        age = 6;
        name = givenName;
    }
}
</pre>


<p>
Notice that the constructor is named "Human", and it returns an object of type
"Human".  This constructor is called whenever we write "new Human(s)", where s
is a String reference.  Now, we can shorten amanda's coming-out party to
</p>



<pre class="example">Human amanda = new Human("Amanda");
amanda.introduce();
</pre>


<p>
These lines accomplish precisely the same result as amanda's previous four
lines.
</p>
<p>
You might ask&hellip;why were we able to create a Human object before we wrote a
constructor?  Java provides every class with a default constructor, which takes
no parameters and does no initializing.  Hence, when we wrote
</p>



<pre class="example">Human amanda = new Human();
</pre>


<p>
we created a new, blank Human.  If the default constructor were explicitly
written, it would look like this:
</p>



<pre class="example">public Human() {
}
</pre>


<p>
Warning:  if you write your own Human constructor, even if it takes parameters,
the default constructor goes away.  If you want to have the default constructor
<span style="text-decoration:underline;">and</span> another constructor, you must define both explicitly.
</p>
<p>
You can override the default constructor by explicitly writing your own
constructor with no parameters.
</p>



<pre class="example">class Human {
    // Include all the stuff from the previous definitions here.

    public Human() {
        age = 0;
        name = "Untitled";
    }
}
</pre>


</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">The "this" Keyword</h3>
<div class="outline-text-3" id="text-1-3">

<p>A method invocation, like "amanda.introduce()", implicitly passes an object
(in this example, amanda) as a parameter called "this".  So we can rewrite our
last constructor as follows without changing its meaning.
</p>



<pre class="example">public Human() {
    this.age = 0;
    this.name = "Untitled";
}
</pre>


<p>
In this case, "this" is optional.  However, if the parameters or local
variables of a method have the same name as the fields of an object, then the
former have priority, and the "this" keyword is needed to refer to the object's
fields.
</p>



<pre class="example">public void change(int age) {
    String name = "Tom";

    this.age = age;
    this.name = name;
}
</pre>


<p>
When we call "amanda.change(11)", "this" is assigned the same value as "amanda"
before the change() method begins execution.
</p>

<p>
<img src="ditaa-images/img14_31fc2b446c21c2e3ba633608733be89a99e5fa88.png"  alt="ditaa-images/img14_31fc2b446c21c2e3ba633608733be89a99e5fa88.png" />
</p>

<p>
Now, when Java executes "this.age = age", it overwrites the 6 with an 11.
When Java executes "this.name = name", it overwrites amanda's name as below.
</p>

<p>
<img src="ditaa-images/img15_2559c49357dcdd9627276b7d92640d5d5913322f.png"  alt="ditaa-images/img15_2559c49357dcdd9627276b7d92640d5d5913322f.png" />
</p>

<p>
A statement like "this = amanda;" will trigger a compile-time error.
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">The "static" Keyword</h3>
<div class="outline-text-3" id="text-1-4">

<p>A <span style="text-decoration:underline;">static field</span> is a single variable shared by a whole class of objects; its
value does not vary from object to object.  For example, if "numberOfHumans" is
the number of Human objects that have been constructed, it is not appropriate
for each object to have its own copy of this number; every time a new Human is
created, we would have to update every Human.
</p>
<p>
If we declare a field "static", there is just one field for the whole class.
Static fields are also called <span style="text-decoration:underline;">class variables</span>.
</p>



<pre class="example">class Human {
    public static int numberOfHumans;

    public int age;
    public String name;

    public Human() {
        numberOfHumans++;    // The constructor increments the number by one.
    }
}
</pre>


<p>
If we want to look at the variable numberOfHumans from another class, we write
it in the usual notation, but we prefix it with the class name rather than the
name of a specific object.
</p>



<pre class="example">int kids = Human.numberOfHumans / 4;  // Good.
int kids = amanda.numberOfHumans / 4; // This works too, but has nothing to
                                      // do with amanda specifically.  Don't
                                      // do this; it's bad (confusing) style.
</pre>


<p>
System.in and System.out are other examples of static fields.
</p>
<p>
Methods can be static too.  A <span style="text-decoration:underline;">static method</span> doesn't implicitly pass an object
as a parameter.
</p>



<pre class="example">class Human {
    ...
    public static void printHumans() {
        System.out.println(numberOfHumans);
    }
}
</pre>


<p>
Now, we can call "Human.printHumans()" from another class.  We can also call
"amanda.printHumans()", and it works, but it's bad style, and amanda will NOT
be passed along as "this".
</p>
<p>
The main() method is always static, because when we run a program, we are not
passing an object in.
</p>

<p>
<img src="ditaa-images/img16_d1097fba485b6f100c1e892f4d01eb6069838a6b.png"  alt="ditaa-images/img16_d1097fba485b6f100c1e892f4d01eb6069838a6b.png" />
</p>

<p>
Any attempt to reference "this" will cause a compile-time error.
</p>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5">Lifetimes of Variables</h3>
<div class="outline-text-3" id="text-1-5">


<ul>
<li>A local variable (declared in a method) is gone forever as soon as the method
  in which it's declared finishes executing.  (If it references an object, the
  object might continue to exist, though.)
</li>
<li>An instance variable (non-static field) lasts as long as the object exists.
  An object lasts as long as there's a reference to it.
</li>
<li>A class variable (static field) lasts as long as the program runs.
</li>
</ul>

</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-03-15T15:12-0700</p>
<p class="author">Author: michael</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
